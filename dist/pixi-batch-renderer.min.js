/*!
 * pixi-batch-renderer
 * Compiled Mon, 06 Jul 2020 17:21:06 UTC
 *
 * pixi-batch-renderer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI=this.PIXI||{},this.PIXI.brend=this.PIXI.brend||{};var __batch_renderer=function(t,e){"use strict";class r{constructor(t,e){this.source=t,this.glslIdentifer=e}}class i extends r{constructor(t){super(t.source,t.attrib),this.type=t.type,this.size=t.size,this.properSize="%notarray%"===t.size||void 0===t.size?1:t.size,this.glType=t.glType,this.glSize=t.glSize,this.normalize=!!t.normalize}static vertexSizeFor(t){return t.reduce((t,r)=>e.ViewableBuffer.sizeOf(r.type)*r.properSize+t,0)}}class s{constructor(t){this.geometryOffset=t,this.textureBuffer=null,this.uidMap=null,this.state=null}upload(t){this.textureBuffer.forEach((e,r)=>{t.texture.bind(e,r)}),t.state.set(this.state)}reset(){this.textureBuffer=this.uidMap=this.state=null,this.batchBuffer&&(this.batchBuffer.length=0)}}class n{constructor(t){this._renderer=t,this._state=null,this._textureCount=t._texturesPerObject,this._textureProperty=t._textureProperty,this._textureLimit=t.MAX_TEXTURES,this._textureBuffer={},this._textureBufferLength=0,this._textureIndexedBuffer=[],this._textureIndexMap={},this._batchBuffer=[],this._batchPool=[],this._batchCount=0,1===this._textureCount?this._putTexture=this._putSingleTexture:this._putTexture=this._putAllTextures}put(t,e){if(this._state){if(this._state.data!==e.data)return!1}else this._state=e;return!!this._put(t)&&(!(this._textureCount>0&&!this._putTexture(t[this._textureProperty]))&&(this._batchBuffer.push(t),!0))}build(t){const e=this._nextBatch();e.geometryOffset=t,this._buildBatch(e),this._state=null,this._batchBuffer=[],this._textureBuffer={},this._textureIndexMap={},this._textureBufferLength=0,this._textureIndexedBuffer=[]}ready(){return 0===this._batchBuffer.length}reset(){this._batchCount=0}access(){return this._batchPool}size(){return this._batchCount}_put(t){return!0}_newBatch(){return new s}_nextBatch(t){this._batchCount===this._batchPool.length&&this._batchPool.push(this._newBatch());const e=this._batchPool[this._batchCount++];return e.reset(),e.geometryOffset=t,e}_buildBatch(t){t.batchBuffer=this._batchBuffer,t.textureBuffer=this._textureIndexedBuffer,t.uidMap=this._textureIndexMap,t.state=this._state}_putSingleTexture(t){"baseTexture"in t&&(t=t.baseTexture);const e=t;if(this._textureBuffer[e.uid])return!0;if(this._textureBufferLength+1<=this._textureLimit){this._textureBuffer[e.uid]=t,this._textureBufferLength+=1;const r=this._textureIndexedBuffer.push(e)-1;return this._textureIndexMap[e.uid]=r,!0}return!1}_putAllTextures(t){let e=0;for(let r=0;r<t.length;r++){const i=t[r].baseTexture?t[r].baseTexture:t[r];this._textureBuffer[i.uid]||++e}if(e+this._textureBufferLength>this._textureLimit)return!1;for(let e=0;e<t.length;e++){const r=t[e].baseTexture?t[e].baseTexture:t[e];if(!this._textureBuffer[r.uid]){this._textureBuffer[r.uid]=r,this._textureBufferLength+=1;const t=this._textureIndexedBuffer.push(r)-1;this._textureIndexMap[r.uid]=t}}return!0}}class u extends e.Geometry{constructor(t,r,i,s,n,u,h){super();const o=new e.Buffer(null,!1,!1),a=r?new e.Buffer(null,!1,!0):null;t.forEach(t=>{const{glslIdentifer:e,glType:r,glSize:i,normalize:s}=t;this.addAttribute(e,o,i,s,r)}),h?this.addAttribute(h,o,1,!1,e.TYPES.FLOAT):(i&&s>0&&this.addAttribute(i,o,s,!0,e.TYPES.FLOAT),n&&this.addAttribute(n,o,1,!1,e.TYPES.FLOAT),u&&this.addAttribute(u,o,1,!1,e.TYPES.FLOAT)),r&&this.addIndex(a),this.attribBuffer=o,this.indexBuffer=a}}class h extends class{constructor(t){this._renderer=t}}{constructor(t){super(t),this._targetCompositeAttributeBuffer=null,this._targetCompositeIndexBuffer=null,this._aIndex=0,this._iIndex=0,this._attribRedirects=t._attribRedirects,this._indexProperty=t._indexProperty,this._vertexCountProperty=t._vertexCountProperty,this._vertexSize=i.vertexSizeFor(this._attribRedirects),this._texturesPerObject=t._texturesPerObject,this._textureProperty=t._textureProperty,this._texIDAttrib=t._texIDAttrib,this._inBatchIDAttrib=t._inBatchIDAttrib,this._uniformIDAttrib=t._uniformIDAttrib,this._masterIDAttrib=t._masterIDAttrib,this._masterIDAttrib?this._vertexSize+=4:(this._vertexSize+=4*this._texturesPerObject,this._inBatchIDAttrib&&(this._vertexSize+=4),this._uniformIDAttrib&&(this._vertexSize+=4)),1===this._texturesPerObject?this._texID=0:this._texturesPerObject>1&&(this._texID=new Array(this._texturesPerObject)),this._aBuffers=[],this._iBuffers=[],this._geometryPool=[]}init(t,e){this._targetCompositeAttributeBuffer=this.getAttributeBuffer(t),this._indexProperty&&(this._targetCompositeIndexBuffer=this.getIndexBuffer(e)),this._aIndex=this._iIndex=0}append(t,e){const r=e,i=t[this._textureProperty];if(1===this._texturesPerObject){const t=i.baseTexture?i.baseTexture.uid:i.uid;this._texID=r.uidMap[t]}else if(this._texturesPerObject>1){let t;for(let e=0;e<i.length;e++){t=i[e];const s=t.BaseTexture?t.baseTexture.uid:t.uid;this._texID[e]=r.uidMap[s]}}this._inBatchIDAttrib&&(this._inBatchID=r.batchBuffer.indexOf(t)),this._uniformIDAttrib&&(this._uniformID=r.uniformMap[this._inBatchID]),this.geometryMerger(t,this)}build(){const t=this._geometryPool.pop()||new u(this._attribRedirects,!0,this._texIDAttrib,this._texturesPerObject,this._inBatchIDAttrib,this._uniformIDAttrib,this._masterIDAttrib);return t.attribBuffer.update(this._targetCompositeAttributeBuffer.float32View),t.indexBuffer.update(this._targetCompositeIndexBuffer),t}release(t){this._geometryPool.push(t)}get geometryMerger(){return this._geometryMerger||(this._geometryMerger=new a(this).compile()),this._geometryMerger}set geometryMerger(t){this._geometryMerger=t}getAttributeBuffer(t){const r=e.utils.nextPow2(t),i=e.utils.log2(r),s=r;this._aBuffers.length<=i&&(this._aBuffers.length=i+1);let n=this._aBuffers[i];return n||(this._aBuffers[i]=n=new e.ViewableBuffer(s*this._vertexSize)),n}getIndexBuffer(t){const r=e.utils.nextPow2(Math.ceil(t/12)),i=e.utils.log2(r),s=12*r;this._iBuffers.length<=i&&(this._iBuffers.length=i+1);let n=this._iBuffers[i];return n||(this._iBuffers[i]=n=new Uint16Array(s)),n}}const o={INDICES_OFFSET:"__offset_indices_",FUNC_SOURCE_BUFFER:"getSourceBuffer",packerArguments:["targetObject","factory"]},a=class{constructor(t){this.packer=t}compile(){const t=this.packer;let e="\n            const compositeAttributes = factory._targetCompositeAttributeBuffer;\n            const compositeIndices = factory._targetCompositeIndexBuffer;\n            let aIndex = factory._aIndex;\n            let iIndex = factory._iIndex;\n            const textureId = factory._texID;\n            const attributeRedirects = factory._attribRedirects;\n        ";t._attribRedirects.forEach((t,r)=>{e+=`\n                let __offset_${r} = 0;\n                const __buffer_${r} = (\n                    ${this._compileSourceBufferExpression(t,r)});\n            `}),e+=`\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;let r=!1;for(let i=0;i<t._attribRedirects.length;i++){const s=t._attribRedirects[i];if(r||(e+=`\n        adjustedAIndex = aIndex / ${this._sizeOf(i)};\n                `),"number"==typeof s.size)for(let t=0;t<s.size;t++)e+=`\n        ${s.type}View[adjustedAIndex++] = __buffer_${i}[__offset_${i}++];\n                    `;else e+=`\n        ${s.type}View[adjustedAIndex++] = __buffer_${i};\n                `;t._attribRedirects[i+1]&&this._sizeOf(i+1)!==this._sizeOf(i)?e+=`\n        aIndex = adjustedAIndex * ${this._sizeOf(i)};\n                `:r=!0}if(r&&4!==this._sizeOf(t._attribRedirects.length-1)&&(e+=`\n        aIndex = adjustedAIndex * ${this._sizeOf(t._attribRedirects.length-1)}\n                `,r=!1),t._masterIDAttrib)r||(e+="\n                    adjustedAIndex = aIndex / 4;\n                "),e+="\n                    float32View[adjustedAIndex++] = factory._masterID;\n                    aIndex = adjustedAIndex * 4;\n            ";else{if(t._texturesPerObject>0)if(t._texturesPerObject>1){r||(e+="\n            adjustedAIndex = aIndex / 4;\n                        ");for(let r=0;r<t._texturesPerObject;r++)e+=`\n            float32View[adjustedAIndex++] = textureId[${r}];\n                        `;e+="\n            aIndex = adjustedAIndex * 4;\n                    "}else e+=r?"\n            float32View[adjustedAIndex++] = textureId;\n            aIndex = adjustedAIndex * 4;\n                    ":"\n            float32View[aIndex / 4] = textureId;\n                    ";t._inBatchIDAttrib&&(e+="\n                    float32View[adjustedAIndex++] = factory._inBatchID;\n                    aIndex = adjustedAIndex * 4;\n                "),t._uniformIDAttrib&&(e+="\n                    float32View[adjustedAIndex++] = factory._uniformID;\n                    aIndex = adjustedAIndex * 4;\n                ")}return e+=`}\n            ${this.packer._indexProperty?"const oldAIndex = this._aIndex;":""}\n            this._aIndex = aIndex;\n        `,this.packer._indexProperty&&(e+=`\n    const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n    const indexCount  = targetObject['${this.packer._indexProperty}'].length;\n\n    for (let j = 0; j < indexCount; j++)\n    {\n        compositeIndices[iIndex++] = verticesBefore + targetObject['${this.packer._indexProperty}'][j];\n    }\n\n    this._iIndex = iIndex;\n            `),new Function(...o.packerArguments,e)}_compileSourceBufferExpression(t,e){return"string"==typeof t.source?`targetObject['${t.source}']`:`attributeRedirects[${e}].source(targetObject, factory._renderer)`}_compileVertexCountExpression(){return this.packer._vertexCountProperty?"string"==typeof this.packer._vertexCountProperty?`targetObject.${this.packer._vertexCountProperty}`:`${this.packer._vertexCountProperty}`:`__buffer_0.length / ${this.packer._attribRedirects[0].size}`}_sizeOf(t){return e.ViewableBuffer.sizeOf(this.packer._attribRedirects[t].type)}};function f(t,e){return"string"==typeof e?t[e]:e}function c(t,e){return"string"==typeof e?t[e]:e(t)}class _{constructor(t){this.renderer=t}draw(){const{renderer:t,_batchFactory:e,_geometryFactory:r,_indexProperty:i}=this.renderer,s=e.access(),n=e.size(),u=r.build(),{gl:h}=t;s[0].upload(t),t.shader.bind(this.renderer._shader,!1),t.geometry.bind(u);for(let e=0;e<n;e++){const r=s[e];r.upload(t),t.shader.bind(this.renderer._shader,!1),i?h.drawElements(h.TRIANGLES,r.$indexCount,h.UNSIGNED_SHORT,2*r.geometryOffset):h.drawArrays(h.TRIANGLES,r.geometryOffset,r.$vertexCount),r.reset()}r.release(u)}}class d extends e.ObjectRenderer{constructor(t,r){super(t),this._attribRedirects=r.attribSet,this._indexProperty=r.indexProperty,this._vertexCountProperty=r.vertexCountProperty,this._textureProperty=r.textureProperty,this._texturesPerObject=void 0!==r.texturesPerObject?r.texturesPerObject:1,this._texIDAttrib=r.texIDAttrib,this._inBatchIDAttrib=r.inBatchIDAttrib,this._stateFunction=r.stateFunction||(()=>e.State.for2d()),this._shaderFunction=r.shaderFunction,this._BatchFactoryClass=r.BatchFactoryClass||n,this._BatchGeometryFactoryClass=r.BatchGeometryFactoryClass||h,this._BatchDrawerClass=r.BatchDrawerClass||_,this._uniformRedirects=r.uniformSet||null,this._uniformIDAttrib=r.uniformIDAttrib,this._masterIDAttrib=r.masterIDAttrib,this.options=r,r.masterIDAttrib&&(this._texIDAttrib=this._masterIDAttrib,this._uniformIDAttrib=this._masterIDAttrib,this._inBatchIDAttrib=this._masterIDAttrib),this.renderer.runners.contextChange.add(this),this.renderer.gl&&this.contextChange(),this._objectBuffer=[],this._bufferedVertices=0,this._bufferedIndices=0,this._shader=null}contextChange(){const t=this.renderer.gl;e.settings.PREFER_ENV===e.ENV.WEBGL_LEGACY?this.MAX_TEXTURES=1:this.MAX_TEXTURES=Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),e.settings.SPRITE_MAX_TEXTURES),this._batchFactory=new this._BatchFactoryClass(this),this._geometryFactory=new this._BatchGeometryFactoryClass(this),this._drawer=new this._BatchDrawerClass(this)}start(){this._objectBuffer.length=0,this._bufferedVertices=0,this._bufferedIndices=0,this._shader=this._shaderFunction(this)}render(t){this._objectBuffer.push(t),this._bufferedVertices+=this._vertexCountFor(t),this._indexProperty&&(this._bufferedIndices+=f(t,this._indexProperty).length)}flush(){const{_batchFactory:t,_geometryFactory:e,_stateFunction:r}=this,i=this._objectBuffer,s=i.length;t.reset(),e.init(this._bufferedVertices,this._bufferedIndices);let n=0;for(let e=0;e<s;){const s=i[e];t.put(s,c(s,r))?++e:(t.build(n),n=e)}t.ready()||t.build(n);const u=t.access(),h=t.size();let o=0;for(let t=0;t<h;t++){const r=u[t],i=r.batchBuffer,s=i.length;let n=0,h=0;r.geometryOffset=o;for(let t=0;t<s;t++){const s=i[t];this._indexProperty?h+=f(s,this._indexProperty).length:n+=f(s,this._vertexCountProperty),e.append(s,r)}r.$vertexCount=n,r.$indexCount=h,o+=r.$indexCount}this._drawer.draw()}stop(){this._bufferedVertices&&this.flush()}_vertexCountFor(t){return this._vertexCountProperty?f(t,this._vertexCountProperty):c(t,this._attribRedirects[0].source).length/this._attribRedirects[0].size}}function x(t,e,r){return t.replace(new RegExp(e,"g"),r)}function l(t){return`${t.MAX_TEXTURES}`}const b={uniformsPerBatch:t=>`${t._batchFactory.MAX_UNIFORMS}`};class p extends s{constructor(t,e){super(e),this.renderer=t,this.uniformBuffer=null,this.uniformMap=null,this.uniformLength=0}upload(t){super.upload(t);const{_uniformRedirects:e,_shader:r}=this.renderer;for(let t=0,i=e.length;t<i;t++){const i=e[t].glslIdentifer;r.uniforms[i]=this.uniformBuffer[i]}}reset(){super.reset();for(const t in this.uniformBuffer)this.uniformBuffer[t].length=0}}return t.AggregateUniformsBatch=p,t.AggregateUniformsBatchFactory=class extends n{constructor(t){super(t),this.MAX_UNIFORMS=Math.floor(Math.min(t.renderer.gl.getParameter(t.renderer.gl.MAX_VERTEX_UNIFORM_VECTORS),t.renderer.gl.getParameter(t.renderer.gl.MAX_FRAGMENT_UNIFORM_VECTORS))/(4*t._uniformRedirects.length)),this.uniformBuffer=this._createUniformBuffer(),this.uniformMap=[],this.uniformLength=0}_newBatch(){const t=new p(this._renderer);return t.uniformBuffer=this._createUniformBuffer(),t.uniformMap=[],t}_put(t){if(!this._renderer._uniformIDAttrib&&this.uniformLength>=0){return this._matchUniforms(t)>=0}if(this.uniformLength+1>=this.MAX_UNIFORMS)return!1;if(this._renderer._uniformIDAttrib){const e=this._matchUniforms(t);if(e>=0)return this.uniformMap.push(e),!0}for(let e=0,r=this._renderer._uniformRedirects.length;e<r;e++){const r=this._renderer._uniformRedirects[e],{source:i,glslIdentifer:s}=r;this.uniformBuffer[s].push("string"==typeof i?t[i]:i(t,this._renderer))}return this.uniformMap.push(this.uniformLength),++this.uniformLength,!0}_buildBatch(t){super._buildBatch(t);const e=t.uniformBuffer,r=t.uniformMap;t.uniformBuffer=this.uniformBuffer,t.uniformMap=this.uniformMap,t.uniformLength=this.uniformLength,this.uniformBuffer=e,this.uniformMap=r,this.uniformLength=0,this._resetUniformBuffer(this.uniformBuffer),this.uniformMap.length=0}_createUniformBuffer(){const t={};for(let e=0,r=this._renderer._uniformRedirects.length;e<r;e++){t[this._renderer._uniformRedirects[e].glslIdentifer]=[]}return t}_resetUniformBuffer(t){for(let e=0,r=this._renderer._uniformRedirects.length;e<r;e++){t[this._renderer._uniformRedirects[e].glslIdentifer].length=0}}_matchUniforms(t){const e=this._renderer._uniformRedirects;for(let r=this.uniformLength-1;r>=0;r--){let i=!0;for(let s=0,n=e.length;s<n;s++){const{glslIdentifer:n,source:u}=e[s],h="string"==typeof u?t[u]:u(t,this._renderer);if(!this._compareUniforms(h,this.uniformBuffer[n][r])){i=!1;break}}if(i)return r}return-1}_compareUniforms(t,r){if(t===r)return!0;if(t.group||r.group)return!1;if(t.equals)return t.equals(r);if(Array.isArray(t)&&Array.isArray(r)){if(t.length!==r.length)return!1;for(let e=0,i=t.length;e<i;e++)if(t[e]!==r[e])return!1;return!0}return t instanceof e.Point&&r instanceof e.Point?t.x===r.x&&t.y===r.y:t instanceof e.Matrix&&r instanceof e.Matrix?t.a===r.a&&t.b===r.b&&t.c===r.c&&t.d===r.d&&t.tx===r.tx&&t.ty===r.ty:t instanceof e.BaseTexture&&r instanceof e.BaseTexture&&t.uid===r.uid}},t.AttributeRedirect=i,t.Batch=s,t.BatchGenerator=n,t.BatchGeometryFactory=h,t.BatchRenderer=d,t.BatchRendererPluginFactory=class{static from(t){return class extends(t.BatchRendererClass||d){constructor(e){super(e,t)}}}},t.BatchShaderFactory=class{constructor(t,e,r={},i={},s=!0){i["%texturesPerBatch%"]||(i["%texturesPerBatch%"]=l),i["%uniformsPerBatch%"]||(i["%uniformsPerBatch%"]=b.uniformsPerBatch),this._vertexShaderTemplate=t,this._fragmentShaderTemplate=e,this._uniforms=r,this._templateInjectors=i,this.disableVertexShaderTemplate=s,this._cache={},this._cState=null}derive(){return t=>{const e=this._generateInjectorBasedState(t),r=this._cache[e];return r||this._generateShader(e,t)}}_generateInjectorBasedState(t){let e="";const r=this._cState={};for(const i in this._templateInjectors){const s=this._templateInjectors[i](t);e+=s,r[i]=s}return e}_generateShader(t,r){let i=this._vertexShaderTemplate.slice(0),s=this._fragmentShaderTemplate.slice(0);for(const t in this._cState)this.disableVertexShaderTemplate||(i=x(i,t,this._cState[t])),s=x(s,t,this._cState[t]);const n=e.Shader.from(i,s,this._uniforms),u=new Array(r.MAX_TEXTURES);for(let t=0;t<u.length;t++)u[t]=t;return n.uniforms.uSamplers=u,this._cache[t]=n,n}},t.Redirect=r,t.UniformRedirect=class extends r{constructor(t){super(t.source,t.uniform)}},t}({},PIXI);Object.assign(this.PIXI.brend,__batch_renderer);
//# sourceMappingURL=pixi-batch-renderer.min.js.map
