/*!
 * pixi-batch-renderer
 * Compiled Wed, 08 Apr 2020 18:16:54 UTC
 *
 * pixi-batch-renderer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI=this.PIXI||{},this.PIXI.brend=this.PIXI.brend||{};var __batch_renderer=function(e,t){"use strict";class r{constructor(e,t){this.source=e,this.glslIdentifer=t}}class s extends r{constructor(e){super(e.source,e.attrib),this.type=e.type,this.size=e.size,this.properSize="%notarray%"===e.size?1:e.size,this.glType=e.glType,this.glSize=e.glSize,this.normalize=!!e.normalize}static vertexSizeFor(e){return e.reduce((e,r)=>t.ViewableBuffer.sizeOf(r.type)*r.properSize+e,0)}}class i{constructor(e,t,r,s=!0){this._state=null,this._textureIncrement=e,this._textureLimit=t,this._textureProperty=r,this._batchBuffer=[],this._textureBuffer={},this._textureBufferLength=0,this._textureIndexedBuffer=[],this._textureIndexMap={},this.enableTextureReduction=s,this._putTexture=s?1===e?this._putOnlyTexture:this._putTextureArray:1===e?this._putTextureWithoutReduction:this._putTextureArrayWithoutReduction}onPut(e){return!0}put(e,t){if(this._state){if(this._state.data!==t.data)return!1}else this._state=t;return!!this.onPut(e)&&(!(this._textureIncrement>0&&!this._putTexture(e[this._textureProperty]))&&(this._batchBuffer.push(e),!0))}finalize(e){e.batchBuffer=this._batchBuffer,e.textureBuffer=this._textureIndexedBuffer,e.uidMap=this.enableTextureReduction?this._textureIndexMap:null,e.state=this._state,this._state=null,this._batchBuffer=[],this._textureBuffer={},this._textureIndexMap={},this._textureBufferLength=0,this._textureIndexedBuffer=[]}_putOnlyTexture(e){e.baseTexture&&(e=e.baseTexture);const t=e;if(this._textureBuffer[t.uid])return!0;if(this._textureBufferLength+1<=this._textureLimit){this._textureBuffer[t.uid]=e,this._textureBufferLength+=1;const r=this._textureIndexedBuffer.push(t)-1;return this._textureIndexMap[t.uid]=r,!0}return!1}_putTextureArray(e){let t=0;for(let r=0;r<e.length;r++){const s=e[r].baseTexture?e[r].baseTexture:e[r];this._textureBuffer[s.uid]||++t}if(t+this._textureBufferLength>this._textureLimit)return!1;for(let t=0;t<e.length;t++){const r=e[t].baseTexture?e[t].baseTexture:e[t];if(!this._textureBuffer[r.uid]){this._textureBuffer[r.uid]=r,this._textureBufferLength+=1;const e=this._textureIndexedBuffer.push(r)-1;this._textureIndexMap[r.uid]=e}}return!0}_putTextureWithoutReduction(e){return e.baseTexture&&(e=e.baseTexture),!(this._textureBufferLength+1>this._textureLimit)&&(this._textureIndexedBuffer.push(e),!0)}_putTextureArrayWithoutReduction(e){if(this._textureBufferLength+e.length>this._textureLimit)return!1;for(let t=0;t<e.length;t++)this._textureIndexedBuffer.push(e[t].baseTexture?e[t].baseTexture:e[t]);return!0}}class n{constructor(e){this.geometryOffset=e,this.textureBuffer=null,this.uidMap=null,this.state=null}upload(e){this.textureBuffer.forEach((t,r)=>{e.texture.bind(t,r)}),e.state.set(this.state)}reset(){this.textureBuffer=this.uidMap=this.state=null}}class u extends t.Geometry{constructor(e,r,s,i){super();const n=new t.Buffer(null,!1,!1),u=r?new t.Buffer(null,!1,!0):null;e.forEach(e=>{const{glslIdentifer:t,glType:r,glSize:s,normalize:i}=e;this.addAttribute(t,n,s,i,r)}),s&&i>0&&this.addAttribute(s,n,i,!0,t.TYPES.FLOAT),r&&this.addIndex(u),this.attribBuffer=n,this.indexBuffer=u}}class h{constructor(e,t,r,i=s.vertexSizeFor(e),n){i+=4*n,this._targetCompositeAttributeBuffer=null,this._targetCompositeIndexBuffer=null,this._aIndex=0,this._iIndex=0,this._attribRedirects=e,this._indexProperty=t,this._vertexCountProperty=r,this._vertexSize=i,this._texturePerObject=n,this._aBuffers=[],this._iBuffers=[],this._geometryPool=[]}get compositeAttributes(){return this._targetCompositeAttributeBuffer}get compositeIndices(){return this._targetCompositeIndexBuffer}init(e,t){this._targetCompositeAttributeBuffer=this.getAttributeBuffer(e),this._indexProperty&&(this._targetCompositeIndexBuffer=this.getIndexBuffer(t)),this._aIndex=this._iIndex=0}append(e,t){this.textureId=t,this.geometryMerger(e,this)}build(){const e=this._geometryPool.pop()||new u(this._attribRedirects,!0,"aInBatchID",this._texturePerObject);return e.attribBuffer.update(this._targetCompositeAttributeBuffer.rawBinaryData),e.indexBuffer.update(this._targetCompositeIndexBuffer),e}release(e){this._geometryPool.push(e)}get geometryMerger(){return this._geometryMerger||(this._geometryMerger=new a(this).compile()),this._geometryMerger}set geometryMerger(e){this._geometryMerger=e}getAttributeBuffer(e){const r=t.utils.nextPow2(Math.ceil(e/8)),s=t.utils.log2(r),i=8*r;this._aBuffers.length<=s&&(this._aBuffers.length=s+1);let n=this._aBuffers[s];return n||(this._aBuffers[i]=n=new t.ViewableBuffer(i*this._vertexSize)),n}getIndexBuffer(e){const r=t.utils.nextPow2(Math.ceil(e/12)),s=t.utils.log2(r),i=12*r;this._iBuffers.length<=s&&(this._iBuffers.length=s+1);let n=this._iBuffers[s];return n||(this._iBuffers[s]=n=new Uint16Array(i)),n}}const o={INDICES_OFFSET:"__offset_indices_",FUNC_SOURCE_BUFFER:"getSourceBuffer",packerArguments:["targetObject","factory"]},a=class{constructor(e){this.packer=e}compile(){const e=this.packer;let t="";e._attribRedirects.forEach((e,r)=>{t+=`\n                let __offset_${r} = 0;\n                const __buffer_${r} = (\n                    ${this._compileSourceBufferExpression(e,r)});\n            `}),t+=`\n            const compositeAttributes = factory._targetCompositeAttributeBuffer;\n            const compositeIndices = factory._targetCompositeIndexBuffer;\n            let aIndex = factory._aIndex;\n            let iIndex = factory._iIndex;\n            const textureId = factory.textureId;\n            const attributeRedirects = factory.attributeRedirects;\n\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;let r=!1;for(let s=0;s<e._attribRedirects.length;s++){const i=e._attribRedirects[s];if(r||(t+=`\n                    adjustedAIndex = aIndex / ${this._sizeOf(s)};\n                `),"number"==typeof i.size)for(let e=0;e<i.size;e++)t+=`\n                        ${i.type}View[adjustedAIndex++] =\n                            __buffer_${s}[__offset_${s}++];\n                    `;else t+=`\n                        ${i.type}View[adjustedAIndex++] =\n                            __buffer_${s};\n                `;e._attribRedirects[s+1]&&this._sizeOf(s+1)!==this._sizeOf(s)?t+=`\n                    aIndex = adjustedAIndex * ${this._sizeOf(s)};\n                `:r=!0}if(r&&4!==this._sizeOf(e._attribRedirects.length-1)&&(t+=`\n                    aIndex = adjustedAIndex * ${this._sizeOf(e._attribRedirects.length-1)}\n                `,r=!1),e._texturePerObject>0)if(e._texturePerObject>1){r||(t+="\n                        adjustedAIndex = aIndex / 4;\n                    ");for(let r=0;r<e._texturePerObject;r++)t+=`\n                        float32View[adjustedAIndex++] = textureId[${r}];\n                    `;t+="\n                    aIndex = adjustedAIndex * 4;\n                "}else t+=r?"\n                    float32View[adjustedAIndex++] = textureId;\n                    aIndex = adjustedAIndex * 4;\n                ":"\n                    float32View[aIndex] = textureId;\n                    aIndex += 4;\n                ";return t+=`}\n            ${this.packer._indexProperty?"const oldAIndex = this._aIndex;":""}\n            this._aIndex = aIndex;\n        `,this.packer._indexProperty&&(t+=`\n                const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n                const indexCount\n                    = targetObject['${this.packer._indexProperty}'].length;\n\n                for (let j = 0; j < indexCount; j++)\n                {\n                    compositeIndices[iIndex++] = verticesBefore +\n                        targetObject['${this.packer._indexProperty}'][j];\n                }\n\n                this._iIndex = iIndex;\n            `),new Function(...o.packerArguments,t)}_compileSourceBufferExpression(e,t){return"string"==typeof e.source?`targetObject['${e.source}']`:`attributeRedirects[${t}].source(targetObject)`}_compileVertexCountExpression(){return this.packer._vertexCountProperty?"string"==typeof this.packer._vertexCountProperty?`targetObject.${this.packer._vertexCountProperty}`:`${this.packer._vertexCountProperty}`:`__buffer_0.length / ${this.packer._attribRedirects[0].size}`}_sizeOf(e){return t.ViewableBuffer.sizeOf(this.packer._attribRedirects[e].type)}};function f(e,t){return"string"==typeof t?e[t]:t}function c(e,t){return"string"==typeof t?e[t]:t(e)}class _ extends t.ObjectRenderer{constructor(e,t,r,s,n,u,o,a,f,c=new h(t,r,s,void 0,u),d=i){super(e),this._attributeRedirects=t,this._indexProperty=r,this._vertexCountProperty=s,this._textureProperty=n,this._texturePerObject=u,this._textureAttribute=o,this._stateFunction=a,this._shaderFunction=f,this._BatchGeneratorClass=d,this._batchGenerator=null,this.renderer.runners.contextChange.add(this),this.renderer.gl&&this.contextChange(),this._geometryFactory=c,this._geom=_.generateCompositeGeometry(t,!!r,o,u),this._objectBuffer=[],this._bufferedVertices=0,this._bufferedIndices=0,this._shader=null,this._batchPool=[],this._batchCount=0}contextChange(){const e=this.renderer.gl;if(t.settings.PREFER_ENV===t.ENV.WEBGL_LEGACY?this.MAX_TEXTURES=1:this.MAX_TEXTURES=Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),t.settings.SPRITE_MAX_TEXTURES),this._batchGenerator=new this._BatchGeneratorClass(this._texturePerObject,this.MAX_TEXTURES,this._textureProperty,!0),!this._batchGenerator.enableTextureReduction)throw new Error("PIXI.brend.BatchRenderer does not support batch generation without texture reduction enabled.")}start(){this._objectBuffer.length=0,this._bufferedVertices=0,this._bufferedIndices=0,this._shader=this._shaderFunction(this),this._shader.uniforms.uSamplers&&(this._shader.uniforms.uSamplers=_.generateTextureArray(this.MAX_TEXTURES)),this.renderer.shader.bind(this._shader,!1)}render(e){this._objectBuffer.push(e),this._bufferedVertices+=this._vertexCountFor(e),this._indexProperty&&(this._bufferedIndices+=f(e,this._indexProperty).length)}flush(){const{_batchGenerator:e,_geom:t,_geometryFactory:r,renderer:s,_stateFunction:i,_textureProperty:n,_texturePerObject:u}=this,h=s.gl,o=this._objectBuffer,a=o.length;this._batchCount=0,r.init(this._bufferedVertices,this._bufferedIndices);let _=0;for(let t=0;t<a;){const r=o[t];e.put(r,c(r,i))?++t:(e.finalize(this._newBatch(_)),_=t)}0!==e._batchBuffer.length&&e.finalize(this._newBatch(_));let d=1===this._texturePerObject?0:new Array(u);for(let e=0;e<this._batchCount;e++){const t=this._batchPool[e],s=t.batchBuffer,i=s.length,h=t.uidMap;let o=0,a=0;for(let e=0;e<i;e++){const i=s[e];this._indexProperty?a+=f(i,this._indexProperty).length:o+=f(i,this._vertexCountProperty),t.$vertexCount=o,t.$indexCount=a;const c=i[n];let _;if(1===u)_=c.baseTexture?c.baseTexture.uid:c.uid,d=h[_];else{let e;for(let t=0;t<c.length;t++)e=c[t],_=e.BaseTexture?e.baseTexture.uid:e.uid,d[t]=h[_]}r.append(i,d)}}t.$buffer.update(r.compositeAttributes.float32View),t.getIndex().update(r.compositeIndices),s.geometry.bind(t),s.geometry.updateBuffers();for(let e=0;e<this._batchCount;e++){const t=this._batchPool[e];t.upload(s),this._indexProperty?h.drawElements(h.TRIANGLES,t.$indexCount,h.UNSIGNED_SHORT,2*t.geometryOffset):h.drawArrays(h.TRIANGLES,t.geometryOffset,t.$vertexCount),t.reset()}}stop(){this._bufferedVertices&&this.flush()}_newBatch(e){if(this._batchCount===this._batchPool.length){const t=new n(e);return this._batchPool.push(t),++this._batchCount,t}const t=this._batchPool[this._batchCount++];return t.reset(),t.geometryOffset=e,t}_vertexCountFor(e){return this._vertexCountProperty?f(e,this._vertexCountProperty):c(e,this._attributeRedirects[0].source).length/this._attributeRedirects[0].size}static generateCompositeGeometry(e,r,s,i){const n=new t.Geometry,u=new t.Buffer(null,!1,!1),h=r?new t.Buffer(null,!1,!0):null;return e.forEach(e=>{const{glslIdentifer:t,glType:r,glSize:s,normalize:i}=e;n.addAttribute(t,u,s,i,r)}),s&&i>0&&n.addAttribute(s,u,i,!0,t.TYPES.FLOAT),r&&n.addIndex(h),n.$buffer=u,n}static generateTextureArray(e){const t=new Int32Array(e);for(let r=0;r<e;r++)t[r]=r;return t}}function d(e,t,r){return e.replace(new RegExp(t,"g"),r)}function x(e){return`${e.MAX_TEXTURES}`}return e.AttributeRedirect=s,e.Batch=n,e.BatchGenerator=i,e.BatchRenderer=_,e.BatchRendererPluginFactory=class{static from(e,t,r,s,i,n,u,h,o,a,f=_){return class extends f{constructor(f){super(f,e,t,r,s,i,n,u,h,o,a)}}}},e.GeometryPacker=h,e.Redirect=r,e.ShaderGenerator=class{constructor(e,t,r={},s={"%texturesPerBatch%":x},i=!0){s["%texturesPerBatch%"]||(s["%texturesPerBatch%"]=x),this._vertexShaderTemplate=e,this._fragmentShaderTemplate=t,this._uniforms=r,this._templateInjectors=s,this.disableVertexShaderTemplate=i,this._cache={},this._cState=null}generateFunction(){return e=>{const t=this._generateInjectorBasedState(e),r=this._cache[t];return r||this._generateShader(t)}}_generateInjectorBasedState(e){let t="";const r=this._cState={};for(const s in this._templateInjectors){const i=this._templateInjectors[s](e);t+=i,r[s]=i}return t}_generateShader(e){let r=this._vertexShaderTemplate.slice(0),s=this._fragmentShaderTemplate.slice(0);for(const e in this._cState)this.disableVertexShaderTemplate||(r=d(r,e,this._cState[e])),s=d(s,e,this._cState[e]);const i=t.Shader.from(r,s,this._uniforms);return this._cache[e]=i,i}},e}({},PIXI);Object.assign(this.PIXI.brend,__batch_renderer);
//# sourceMappingURL=pixi-batch-renderer.min.js.map
