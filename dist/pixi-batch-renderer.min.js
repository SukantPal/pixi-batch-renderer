/*!
 * pixi-batch-renderer
 * Compiled Fri, 10 Apr 2020 15:43:22 UTC
 *
 * pixi-batch-renderer is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
this.PIXI=this.PIXI||{},this.PIXI.brend=this.PIXI.brend||{};var __batch_renderer=function(t,e){"use strict";class r{constructor(t,e){this.source=t,this.glslIdentifer=e}}class s extends r{constructor(t){super(t.source,t.attrib),this.type=t.type,this.size=t.size,this.properSize="%notarray%"===t.size||void 0===t.size?1:t.size,this.glType=t.glType,this.glSize=t.glSize,this.normalize=!!t.normalize}static vertexSizeFor(t){return t.reduce((t,r)=>e.ViewableBuffer.sizeOf(r.type)*r.properSize+t,0)}}class i{constructor(t){this.geometryOffset=t,this.textureBuffer=null,this.uidMap=null,this.state=null}upload(t){this.textureBuffer.forEach((e,r)=>{t.texture.bind(e,r)}),t.state.set(this.state)}reset(){this.textureBuffer=this.uidMap=this.state=null,this.batchBuffer&&(this.batchBuffer.length=0)}}class n{constructor(t){this._state=null,this._textureCount=t._texturesPerObject,this._textureProperty=t._textureProperty,this._textureLimit=t.MAX_TEXTURES,this._textureBuffer={},this._textureBufferLength=0,this._textureIndexedBuffer=[],this._textureIndexMap={},this._batchBuffer=[],this._batchPool=[],this._batchCount=0,1===this._textureCount?this._putTexture=this._putSingleTexture:this._putTexture=this._putAllTextures}put(t,e){if(this._state){if(this._state.data!==e.data)return!1}else this._state=e;return!!this._put(t)&&(!(this._textureCount>0&&!this._putTexture(t[this._textureProperty]))&&(this._batchBuffer.push(t),!0))}build(t){const e=this._nextBatch();e.geometryOffset=t,this._buildBatch(e),this._state=null,this._batchBuffer=[],this._textureBuffer={},this._textureIndexMap={},this._textureBufferLength=0,this._textureIndexedBuffer=[]}ready(){return 0===this._batchBuffer.length}reset(){this._batchCount=0}access(){return this._batchPool}size(){return this._batchCount}_put(t){return!0}_newBatch(){return new i}_nextBatch(t){this._batchCount===this._batchPool.length&&this._batchPool.push(this._newBatch());const e=this._batchPool[this._batchCount++];return e.reset(),e.geometryOffset=t,e}_buildBatch(t){t.batchBuffer=this._batchBuffer,t.textureBuffer=this._textureIndexedBuffer,t.uidMap=this._textureIndexMap,t.state=this._state}_putSingleTexture(t){"baseTexture"in t&&(t=t.baseTexture);const e=t;if(this._textureBuffer[e.uid])return!0;if(this._textureBufferLength+1<=this._textureLimit){this._textureBuffer[e.uid]=t,this._textureBufferLength+=1;const r=this._textureIndexedBuffer.push(e)-1;return this._textureIndexMap[e.uid]=r,!0}return!1}_putAllTextures(t){let e=0;for(let r=0;r<t.length;r++){const s=t[r].baseTexture?t[r].baseTexture:t[r];this._textureBuffer[s.uid]||++e}if(e+this._textureBufferLength>this._textureLimit)return!1;for(let e=0;e<t.length;e++){const r=t[e].baseTexture?t[e].baseTexture:t[e];if(!this._textureBuffer[r.uid]){this._textureBuffer[r.uid]=r,this._textureBufferLength+=1;const t=this._textureIndexedBuffer.push(r)-1;this._textureIndexMap[r.uid]=t}}return!0}}class u extends e.Geometry{constructor(t,r,s,i){super();const n=new e.Buffer(null,!1,!1),u=r?new e.Buffer(null,!1,!0):null;t.forEach(t=>{const{glslIdentifer:e,glType:r,glSize:s,normalize:i}=t;this.addAttribute(e,n,s,i,r)}),s&&i>0&&this.addAttribute(s,n,i,!0,e.TYPES.FLOAT),r&&this.addIndex(u),this.attribBuffer=n,this.indexBuffer=u}}class h extends class{constructor(t){}}{constructor(t){super(t),this._targetCompositeAttributeBuffer=null,this._targetCompositeIndexBuffer=null,this._aIndex=0,this._iIndex=0,this._attribRedirects=t._attribRedirects,this._indexProperty=t._indexProperty,this._vertexCountProperty=t._vertexCountProperty,this._vertexSize=s.vertexSizeFor(this._attribRedirects),this._texturesPerObject=t._texturesPerObject,this._textureProperty=t._textureProperty,this._texIDAttrib=t._texIDAttrib,this._vertexSize+=4*this._texturesPerObject,1===this._texturesPerObject?this._texID=0:this._texturesPerObject>1&&(this._texID=new Array(this._texturesPerObject)),this._aBuffers=[],this._iBuffers=[],this._geometryPool=[]}init(t,e){this._targetCompositeAttributeBuffer=this.getAttributeBuffer(t),this._indexProperty&&(this._targetCompositeIndexBuffer=this.getIndexBuffer(e)),this._aIndex=this._iIndex=0}append(t,e){const r=e,s=t[this._textureProperty];if(1===this._texturesPerObject){const t=s.baseTexture?s.baseTexture.uid:s.uid;this._texID=r.uidMap[t]}else if(this._texturesPerObject>1){let t;for(let e=0;e<s.length;e++){t=s[e];const i=t.BaseTexture?t.baseTexture.uid:t.uid;this._texID[e]=r.uidMap[i]}}this.geometryMerger(t,this)}build(){const t=this._geometryPool.pop()||new u(this._attribRedirects,!0,this._texIDAttrib,this._texturesPerObject);return t.attribBuffer.update(this._targetCompositeAttributeBuffer.float32View),t.indexBuffer.update(this._targetCompositeIndexBuffer),t}release(t){this._geometryPool.push(t)}get geometryMerger(){return this._geometryMerger||(this._geometryMerger=new o(this).compile()),this._geometryMerger}set geometryMerger(t){this._geometryMerger=t}getAttributeBuffer(t){const r=e.utils.nextPow2(Math.ceil(t/8)),s=e.utils.log2(r),i=8*r;this._aBuffers.length<=s&&(this._aBuffers.length=s+1);let n=this._aBuffers[s];return n||(this._aBuffers[i]=n=new e.ViewableBuffer(i*this._vertexSize)),n}getIndexBuffer(t){const r=e.utils.nextPow2(Math.ceil(t/12)),s=e.utils.log2(r),i=12*r;this._iBuffers.length<=s&&(this._iBuffers.length=s+1);let n=this._iBuffers[s];return n||(this._iBuffers[s]=n=new Uint16Array(i)),n}}const a={INDICES_OFFSET:"__offset_indices_",FUNC_SOURCE_BUFFER:"getSourceBuffer",packerArguments:["targetObject","factory"]},o=class{constructor(t){this.packer=t}compile(){const t=this.packer;let e="";t._attribRedirects.forEach((t,r)=>{e+=`\n                let __offset_${r} = 0;\n                const __buffer_${r} = (\n                    ${this._compileSourceBufferExpression(t,r)});\n            `}),e+=`\n            const compositeAttributes = factory._targetCompositeAttributeBuffer;\n            const compositeIndices = factory._targetCompositeIndexBuffer;\n            let aIndex = factory._aIndex;\n            let iIndex = factory._iIndex;\n            const textureId = factory._texID;\n            const attributeRedirects = factory.attributeRedirects;\n\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;let r=!1;for(let s=0;s<t._attribRedirects.length;s++){const i=t._attribRedirects[s];if(r||(e+=`\n                    adjustedAIndex = aIndex / ${this._sizeOf(s)};\n                `),"number"==typeof i.size)for(let t=0;t<i.size;t++)e+=`\n                        ${i.type}View[adjustedAIndex++] =\n                            __buffer_${s}[__offset_${s}++];\n                    `;else e+=`\n                        ${i.type}View[adjustedAIndex++] =\n                            __buffer_${s};\n                `;t._attribRedirects[s+1]&&this._sizeOf(s+1)!==this._sizeOf(s)?e+=`\n                    aIndex = adjustedAIndex * ${this._sizeOf(s)};\n                `:r=!0}if(r&&4!==this._sizeOf(t._attribRedirects.length-1)&&(e+=`\n                    aIndex = adjustedAIndex * ${this._sizeOf(t._attribRedirects.length-1)}\n                `,r=!1),t._texturesPerObject>0)if(t._texturesPerObject>1){r||(e+="\n                        adjustedAIndex = aIndex / 4;\n                    ");for(let r=0;r<t._texturesPerObject;r++)e+=`\n                        float32View[adjustedAIndex++] = textureId[${r}];\n                    `;e+="\n                    aIndex = adjustedAIndex * 4;\n                "}else e+=r?"\n                    float32View[adjustedAIndex++] = textureId;\n                    aIndex = adjustedAIndex * 4;\n                ":"\n                    float32View[aIndex] = textureId;\n                    aIndex += 4;\n                ";return e+=`}\n            ${this.packer._indexProperty?"const oldAIndex = this._aIndex;":""}\n            this._aIndex = aIndex;\n        `,this.packer._indexProperty&&(e+=`\n                const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n                const indexCount\n                    = targetObject['${this.packer._indexProperty}'].length;\n\n                for (let j = 0; j < indexCount; j++)\n                {\n                    compositeIndices[iIndex++] = verticesBefore +\n                        targetObject['${this.packer._indexProperty}'][j];\n                }\n\n                this._iIndex = iIndex;\n            `),new Function(...a.packerArguments,e)}_compileSourceBufferExpression(t,e){return"string"==typeof t.source?`targetObject['${t.source}']`:`attributeRedirects[${e}].source(targetObject)`}_compileVertexCountExpression(){return this.packer._vertexCountProperty?"string"==typeof this.packer._vertexCountProperty?`targetObject.${this.packer._vertexCountProperty}`:`${this.packer._vertexCountProperty}`:`__buffer_0.length / ${this.packer._attribRedirects[0].size}`}_sizeOf(t){return e.ViewableBuffer.sizeOf(this.packer._attribRedirects[t].type)}};function c(t,e){return"string"==typeof e?t[e]:e}function _(t,e){return"string"==typeof e?t[e]:e(t)}class f{constructor(t){this.renderer=t}draw(){const{renderer:t,_batchFactory:e,_geometryFactory:r,_indexProperty:s}=this.renderer,i=e.access(),n=e.size(),u=r.build(),{gl:h}=t;t.geometry.bind(u);for(let e=0;e<n;e++){const r=i[e];r.upload(t),s?h.drawElements(h.TRIANGLES,r.$indexCount,h.UNSIGNED_SHORT,2*r.geometryOffset):h.drawArrays(h.TRIANGLES,r.geometryOffset,r.$vertexCount),r.reset()}r.release(u)}}class d extends e.ObjectRenderer{constructor(t,r){super(t),this._attribRedirects=r.attribSet,this._indexProperty=r.indexProperty,this._vertexCountProperty=r.vertexCountProperty,this._textureProperty=r.textureProperty,this._texturesPerObject=void 0!==r.texturesPerObject?r.texturesPerObject:1,this._texIDAttrib=r.texIDAttrib,this._stateFunction=r.stateFunction||(()=>e.State.for2d()),this._shaderFunction=r.shaderFunction,this._BatchFactoryClass=r.BatchFactoryClass||n,this._BatchGeometryFactoryClass=r.BatchGeometryFactoryClass||h,this._BatchDrawerClass=r.BatchDrawerClass||f,this.renderer.runners.contextChange.add(this),this.renderer.gl&&this.contextChange(),this._objectBuffer=[],this._bufferedVertices=0,this._bufferedIndices=0,this._shader=null}contextChange(){const t=this.renderer.gl;e.settings.PREFER_ENV===e.ENV.WEBGL_LEGACY?this.MAX_TEXTURES=1:this.MAX_TEXTURES=Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),e.settings.SPRITE_MAX_TEXTURES),this._batchFactory=new this._BatchFactoryClass(this),this._geometryFactory=new this._BatchGeometryFactoryClass(this),this._drawer=new this._BatchDrawerClass(this)}start(){this._objectBuffer.length=0,this._bufferedVertices=0,this._bufferedIndices=0,this._shader=this._shaderFunction(this),this.renderer.shader.bind(this._shader,!1)}render(t){this._objectBuffer.push(t),this._bufferedVertices+=this._vertexCountFor(t),this._indexProperty&&(this._bufferedIndices+=c(t,this._indexProperty).length)}flush(){const{_batchFactory:t,_geometryFactory:e,_stateFunction:r}=this,s=this._objectBuffer,i=s.length;t.reset(),e.init(this._bufferedVertices,this._bufferedIndices);let n=0;for(let e=0;e<i;){const i=s[e];t.put(i,_(i,r))?++e:(t.build(n),n=e)}t.ready()||t.build(n);const u=t.access(),h=t.size();for(let t=0;t<h;t++){const r=u[t],s=r.batchBuffer,i=s.length;let n=0,h=0;for(let t=0;t<i;t++){const i=s[t];this._indexProperty?h+=c(i,this._indexProperty).length:n+=c(i,this._vertexCountProperty),r.$vertexCount=n,r.$indexCount=h,e.append(i,r)}}this._drawer.draw()}stop(){this._bufferedVertices&&this.flush()}_vertexCountFor(t){return this._vertexCountProperty?c(t,this._vertexCountProperty):_(t,this._attribRedirects[0].source).length/this._attribRedirects[0].size}static generateTextureArray(t){const e=new Int32Array(t);for(let r=0;r<t;r++)e[r]=r;return e}}function x(t,e,r){return t.replace(new RegExp(e,"g"),r)}function l(t){return`${t.MAX_TEXTURES}`}return t.AttributeRedirect=s,t.Batch=i,t.BatchGenerator=n,t.BatchRenderer=d,t.BatchRendererPluginFactory=class{static from(t){return class extends(t.BatchRendererClass||d){constructor(e){super(e,t)}}}},t.BatchShaderFactory=class{constructor(t,e,r={},s={"%texturesPerBatch%":l},i=!0){s["%texturesPerBatch%"]||(s["%texturesPerBatch%"]=l),this._vertexShaderTemplate=t,this._fragmentShaderTemplate=e,this._uniforms=r,this._templateInjectors=s,this.disableVertexShaderTemplate=i,this._cache={},this._cState=null}derive(){return t=>{const e=this._generateInjectorBasedState(t),r=this._cache[e];return r||this._generateShader(e,t)}}_generateInjectorBasedState(t){let e="";const r=this._cState={};for(const s in this._templateInjectors){const i=this._templateInjectors[s](t);e+=i,r[s]=i}return e}_generateShader(t,r){let s=this._vertexShaderTemplate.slice(0),i=this._fragmentShaderTemplate.slice(0);for(const t in this._cState)this.disableVertexShaderTemplate||(s=x(s,t,this._cState[t])),i=x(i,t,this._cState[t]);const n=e.Shader.from(s,i,this._uniforms),u=new Array(r.MAX_TEXTURES);for(let t=0;t<u.length;t++)u[t]=t;return n.uniforms.uSamplers=u,this._cache[t]=n,n}},t.GeometryPacker=h,t.Redirect=r,t}({},PIXI);Object.assign(this.PIXI.brend,__batch_renderer);
//# sourceMappingURL=pixi-batch-renderer.min.js.map
