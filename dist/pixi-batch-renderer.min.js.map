{"version":3,"file":"pixi-batch-renderer.min.js","sources":["../src/redirects/Redirect.ts","../src/redirects/AttributeRedirect.ts","../src/BatchGenerator.ts","../src/Batch.ts","../src/BatchGeometryFactory.ts","../src/resolve/resolveConstantOrProperty.ts","../src/resolve/resolveFunctionOrProperty.ts","../src/BatchRenderer.ts","../src/ShaderGenerator.ts","../src/BatchRendererPluginFactory.ts"],"sourcesContent":["import * as PIXI from 'pixi.js';\n\n/**\n * Redirects are used to aggregate the resources needed by the WebGL pipeline to render\n * a display-object. This includes the base primitives (geometry), uniforms, and\n * textures (which are handled as \"special\" uniforms).\n *\n * @memberof PIXI.brend\n * @class\n * @abstract\n * @see PIXI.brend.AttributeRedirect\n */\nexport abstract class Redirect\n{\n    public source: string | ((displayObject: PIXI.DisplayObject) => any);\n    public glslIdentifer: string;\n\n    constructor(source: string | ((displayObject: PIXI.DisplayObject) => any), glslIdentifer: string)\n    {\n        /**\n         * The property on the display-object that holds the resource.\n         *\n         * Instead of a property, you can provide a callback that generates the resource\n         * on invokation.\n         *\n         * @member {string | Function}\n         */\n        this.source = source;\n\n        /**\n         * The shader variable that references the resource, e.g. attribute or uniform\n         * name.\n         * @member {string}\n         */\n        this.glslIdentifer = glslIdentifer;\n    }\n}\n\nexport default Redirect;\n","import * as PIXI from 'pixi.js';\nimport { Redirect } from './Redirect';\n\ninterface IAttributeRedirectOptions\n{\n    source: string | ((db: PIXI.DisplayObject) => any);\n    attrib: string;\n    type: string;\n    size: number | '%notarray%';\n    glType: number;\n    glSize: number;\n    normalize?: boolean;\n}\n\n/**\n * This redirect defines an attribute of a display-object's geometry. The attribute\n * data is expected to be stored in a `PIXI.ViewableBuffer`, in an array, or (if\n * just one element) as the property itself.\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.brend.Redirect\n * @example\n * // This attribute redirect calculates the tint used on top of a texture. Since the\n * // tintMode can change anytime, it is better to use a derived source (function).\n * //\n * // Furthermore, the color is uploaded as four bytes (`attribute vec4 aTint`) while the\n * // source returns an integer. This is done by splitting the 32-bit integer into four\n * // 8-bit bytes.\n * new PIXI.brend.AttributeRedirect(\n *     (tgt: ExampleDisplay) => (tgt.alpha < 1.0 && tgt.tintMode === PREMULTIPLY)\n *          ? premultiplyTint(tgt.rgb, tgt.alpha)\n *          : tgt.rgb + (tgt.alpha << 24);\n *     'aTint',\n *     'int32',\n *     '%notarray%',\n *     PIXI.TYPES.UNSIGNED_BYTE,\n *     4,\n *     true\n * );\n */\nexport class AttributeRedirect extends Redirect\n{\n    public type: string;\n    public size: number | '%notarray%';\n    public glType: PIXI.TYPES;\n    public glSize: number;\n    public normalize: boolean;\n\n    public properSize: number;\n\n    /**\n     * @param {string | Function} source - redirect source\n     * @param {string} glslIdentifer - shader attribute variable\n     * @param {string}[type='float32'] - the type of data stored in the source\n     * @param {number | '%notarray%'}[size=0] - size of the source array ('%notarray' if not an array & just one element)\n     * @param {PIXI.TYPES}[glType=PIXI.TYPES.FLOAT] - data format to be uploaded in\n     * @param {number} glSize - number of elements to be uploaded as (size of source and upload must match)\n     * @param {boolean}[normalize=false] - whether to normalize the data before uploading\n     */\n    constructor(options: IAttributeRedirectOptions)\n    {\n        super(options.source, options.attrib);\n\n        /**\n         * The type of data stored in the source buffer. This can be any of: `int8`, `uint8`,\n         * `int16`, `uint16`, `int32`, `uint32`, or (by default) `float32`.\n         *\n         * @member {string}\n         * @see [PIXI.ViewableBuffer#view]{@link https://pixijs.download/dev/docs/PIXI.ViewableBuffer.html}\n         * @default 'float32'\n         */\n        this.type = options.type;\n\n        /**\n         * Number of elements to extract out of `source` with\n         * the given view type, for one vertex.\n         *\n         * If source isn't an array (only one element), then\n         * you can set this to `'%notarray%'`.\n         *\n         * @member {number | '%notarray%'}\n         */\n        this.size = options.size;\n\n        /**\n         * This is equal to `size` or 1 if size is `%notarray%`.\n         *\n         * @member {number}\n         */\n        this.properSize = (options.size === '%notarray%') ? 1 : options.size;\n\n        /**\n         * Type of attribute, when uploading.\n         *\n         * Normally, you would use the corresponding type for\n         * the view on source. However, to speed up uploads\n         * you can aggregate attribute values in larger data\n         * types. For example, an RGBA vec4 (byte-sized channels)\n         * can be represented as one `Uint32`, while having\n         * a `glType` of `UNSIGNED_BYTE`.\n         *\n         * @member {PIXI.TYPES}\n         */\n        this.glType = options.glType;\n\n        /**\n         * Size of attribute in terms of `glType`.\n         *\n         * Note that `glSize * glType <= size * type`\n         *\n         * @readonly\n         */\n        this.glSize = options.glSize;\n\n        /**\n         * Whether to normalize the attribute values.\n         *\n         * @member {boolean}\n         * @readonly\n         */\n        this.normalize = !!options.normalize;\n    }\n\n    static vertexSizeFor(attributeRedirects: Array<AttributeRedirect>): number\n    {\n        return attributeRedirects.reduce(\n            (acc, redirect) =>\n                (PIXI.ViewableBuffer.sizeOf(redirect.type)\n                    * redirect.properSize)\n                + acc,\n            0);\n    }\n}\n","import { Batch } from './Batch';\n\n/**\n * Used to generate discrete groups/batches of display-objects\n * that can be drawn together. It also keeps a parallel buffer\n * of textures.\n *\n * This class ensures that the WebGL states are equivalent and\n * the texture count doesn't become greater than the no. of\n * texture registers on the GPU. You can extend it and add\n * constraints by overriding `onPut`.\n *\n * WARNING: `BatchRenderer` does not support geometry\n *              packing with texture reduction disabled.\n *\n * @memberof PIXI.brend\n * @class\n */\nexport class BatchFactory\n{\n    public readonly enableTextureReduction: boolean;\n\n    protected _state: PIXI.State;\n    protected _textureIncrement: number;\n    protected _textureLimit: number;\n    protected _textureProperty: number;\n    /** @internal */\n    public _batchBuffer: Array<PIXI.DisplayObject>;\n    protected _textureBuffer: any;\n    protected _textureBufferLength: number;\n    protected _textureIndexedBuffer: Array<PIXI.BaseTexture>;\n    protected _textureIndexMap: any;\n\n    protected _putTexture: any;\n\n    /**\n     * @param {number} textureIncrement - textures per object\n     * @param {number} textureLimit - no. of texture registers in GPU\n     * @param {string} textureProperty - property where texture is kept\n     * @param {boolean} [enableTextureReduction=true] - whether same textures\n     *      aren't counted multiple times. This reduces draw calls and can\n     *      draw huge amounts of objects at the same time. For example,\n     *      if 1000 objects use the same texture, then they can be drawn\n     *      together. Further more if 1000 object use the same 8 textures\n     *      randomly, then they can be drawn together. (provided other\n     *      constraints like state are satisfied.)\n     */\n    constructor(\n        textureIncrement,\n        textureLimit,\n        textureProperty,\n        enableTextureReduction = true,\n    )\n    {\n        /** @private */\n        this._state = null;\n        /** @private */\n        this._textureIncrement = textureIncrement;\n        /** @private */\n        this._textureLimit = textureLimit;\n        /** @private */\n        this._textureProperty = textureProperty;\n        /** @private */\n        this._batchBuffer = [];\n        /** @private */\n        this._textureBuffer = {}; // uid : texture map\n        /** @private */\n        this._textureBufferLength = 0;\n        /** @private */\n        this._textureIndexedBuffer = []; // array of textures\n        /** @private */\n        this._textureIndexMap = {}; // uid : index in above\n        /** @protected */\n        this.enableTextureReduction = enableTextureReduction;\n\n        // this._putTexture is used to handle texture buffering!\n        if (enableTextureReduction)\n        {\n            if (textureIncrement === 1)\n            {\n                /** @private */\n                this._putTexture = this._putOnlyTexture;\n            }\n            else\n            {\n                this._putTexture = this._putTextureArray;\n            }\n        }\n        else if (textureIncrement === 1)\n        {\n            this._putTexture = this._putTextureWithoutReduction;\n        }\n        else\n        {\n            this._putTexture = this._putTextureArrayWithoutReduction;\n        }\n    }\n\n    /**\n     * Overridable method that is called before an object\n     * is put into this batch. It should check compatibility\n     * with other objects, and return true/false accordingly.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object being added\n     * @protected\n     */\n    onPut(targetObject: PIXI.DisplayObject): boolean // eslint-disable-line @typescript-eslint/no-unused-vars\n    {\n        return true;\n    }\n\n    /**\n     * Put an object into this batch.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object to add\n     * @param state {PIXI.State} - state required by that object\n     * @return {boolean} whether the object was added to the\n     *     batch. If it wasn't, you should finalize it.\n     */\n    put(targetObject: PIXI.DisplayObject, state: PIXI.State): boolean\n    {\n        if (!this._state)\n        {\n            this._state = state;\n        }\n        else if (this._state.data !== state.data)\n        {\n            return false;\n        }\n\n        if (!this.onPut(targetObject))\n        {\n            return false;\n        }\n\n        if (this._textureIncrement > 0\n            && !this._putTexture(targetObject[this._textureProperty]))\n        {\n            return false;\n        }\n\n        this._batchBuffer.push(targetObject);\n\n        return true;\n    }\n\n    /**\n     * Finalize this batch by getting its data into a\n     * `Batch` object.\n     *\n     * @param batch {PIXI.brend.Batch}\n     */\n    finalize(batch: Batch): void\n    {\n        batch.batchBuffer = this._batchBuffer;\n        batch.textureBuffer = this._textureIndexedBuffer;\n        batch.uidMap = this.enableTextureReduction\n            ? this._textureIndexMap : null;\n        batch.state = this._state;\n\n        this._state = null;\n        this._batchBuffer = [];\n        this._textureBuffer = {};\n        this._textureIndexMap = {};\n        this._textureBufferLength = 0;\n        this._textureIndexedBuffer = [];\n    }\n\n    _putOnlyTexture(texture: PIXI.Texture): boolean\n    {\n        if (texture.baseTexture)\n        {\n            texture = texture.baseTexture;\n        }\n\n        const baseTexture: PIXI.BaseTexture = texture as PIXI.BaseTexture;\n\n        if (this._textureBuffer[baseTexture.uid])\n        {\n            return true;\n        }\n        else if (this._textureBufferLength + 1 <= this._textureLimit)\n        {\n            this._textureBuffer[baseTexture.uid] = texture;\n            this._textureBufferLength += 1;\n\n            const newLength = this._textureIndexedBuffer.push(baseTexture);\n            const index = newLength - 1;\n\n            this._textureIndexMap[baseTexture.uid] = index;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    _putTextureArray(textureArray: Array<PIXI.Texture>): boolean\n    {\n        let deltaBufferLength = 0;\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture = textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i];\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                ++deltaBufferLength;\n            }\n        }\n\n        if (deltaBufferLength + this._textureBufferLength > this._textureLimit)\n        {\n            return false;\n        }\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture = textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i];\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                this._textureBuffer[texture.uid] = texture;\n                this._textureBufferLength += 1;\n\n                const newLength = this._textureIndexedBuffer.push(texture);\n                const index = newLength - 1;\n\n                this._textureIndexMap[texture.uid] = index;\n            }\n        }\n\n        return true;\n    }\n\n    _putTextureWithoutReduction(texture: PIXI.BaseTexture): boolean\n    {\n        if (texture.baseTexture)\n        {\n            texture = texture.baseTexture;\n        }\n\n        if (this._textureBufferLength + 1 > this._textureLimit)\n        {\n            return false;\n        }\n\n        this._textureIndexedBuffer.push(texture);\n\n        return true;\n    }\n\n    _putTextureArrayWithoutReduction(textureArray: Array<PIXI.Texture>): boolean\n    {\n        if (this._textureBufferLength + textureArray.length\n            > this._textureLimit)\n        {\n            return false;\n        }\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            this._textureIndexedBuffer.push(\n                textureArray[i].baseTexture\n                    ? textureArray[i].baseTexture\n                    : textureArray[i],\n            );\n        }\n\n        return true;\n    }\n}\n\nexport default BatchFactory;\n","import * as PIXI from 'pixi.js';\n\n/**\n * Resources that need to be uploaded to WebGL to render\n * one batch.\n *\n * @memberof PIXI.brend\n * @class\n */\nexport class Batch\n{\n    geometryOffset: number;\n    uidMap: Map<number, number>;\n    state: PIXI.State;\n\n    batchBuffer: Array<PIXI.DisplayObject>;\n    textureBuffer: Array<PIXI.BaseTexture>;\n\n    constructor(geometryOffset: number)\n    {\n        /**\n         * Offset in the geometry (set by `BatchRenderer`)\n         * where this batch is located.\n         *\n         * @member {number}\n         */\n        this.geometryOffset = geometryOffset;\n\n        /**\n         * Buffer of textures that should be uploaded in-order\n         * to GPU texture registers.\n         *\n         * @member {Array<PIXI.Texture>}\n         */\n        this.textureBuffer = null;\n\n        /**\n         * Map of texture-ids into texture-buffer indices.\n         *\n         * @member {Map<number, number>}\n         */\n        this.uidMap = null;\n\n        /**\n         * State required to render this batch.\n         *\n         * @member {PIXI.State}\n         */\n        this.state = null;\n    }\n\n    /**\n     * Uploads the resources required before rendering this\n     * batch.\n     */\n    upload(renderer: PIXI.Renderer): void\n    {\n        this.textureBuffer.forEach((tex, i) =>\n        {\n            renderer.texture.bind(tex, i);\n        });\n\n        renderer.state.set(this.state);\n    }\n\n    /**\n     * Resets all properties to `null` to free up references\n     * to resources.\n     */\n    reset(): void\n    {\n        this.textureBuffer\n            = this.uidMap\n                = this.state\n                    = null;\n    }\n}\n","import { AttributeRedirect } from './redirects/AttributeRedirect';\nimport * as PIXI from 'pixi.js';\nimport Redirect from './redirects/Redirect';\n\n// BatchGeometryFactory uses this class internally to setup the attributes of\n// the batches.\nexport class BatchGeometry extends PIXI.Geometry\n{\n    // Interleaved attribute data buffer\n    attribBuffer: PIXI.Buffer;\n\n    // Batched indicies\n    indexBuffer: PIXI.Buffer;\n\n    constructor(attributeRedirects: AttributeRedirect[],\n        hasIndex: boolean,\n        textureAttribute: string,\n        texturePerObject: number,\n    )\n    {\n        super();\n\n        const attributeBuffer = new PIXI.Buffer(null, false, false);\n        const indexBuffer = hasIndex ? new PIXI.Buffer(null, false, true) : null;\n\n        attributeRedirects.forEach((redirect) =>\n        {\n            const { glslIdentifer, glType, glSize, normalize } = redirect;\n\n            this.addAttribute(glslIdentifer, attributeBuffer, glSize, normalize, glType);\n        });\n\n        if (textureAttribute && texturePerObject > 0)\n        {\n            this.addAttribute(textureAttribute, attributeBuffer, texturePerObject, true, PIXI.TYPES.FLOAT);\n        }\n\n        if (hasIndex)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.attribBuffer = attributeBuffer;\n        this.indexBuffer = indexBuffer;\n    }\n}\n\nexport interface IBatchGeometryFactory\n{\n    init(verticesBatched: number, indiciesBatched: number): void;\n    append(displayObject: number, inBatchId: number): void;\n    build(): PIXI.Geometry;\n    release(geom: PIXI.Geometry): void;\n}\n\n/**\n * This interface defines the methods you need to implement to creating your own batch\n * geometry factory.\n * @memberof PIXI.brend\n * @interface IBatchGeometryFactory\n */\n\n/**\n * Called before the batch renderer starts feeding the display-objects. This can be used\n * to pre-allocated space for the batch geometry.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method init\n * @param {number} verticesBatched\n * @param {number}[indiciesBatched] - optional when display-object's don't use a index buffer\n */\n\n/**\n * Adds the display-object to the batch geometry. If the display-object's shader also uses\n * uniforms (or textures in `uSamplers` uniform), then it will also be given an in-batch\n * ID. This id is used to fetch the corresponding uniform for the \"current\" display-object\n * from an array. `inBatchId` is passed as an attribute `vTextureId`.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method append\n * @param {PIXI.DisplayObject} displayObject\n * @param {number} inBatchId\n */\n\n/**\n * This should wrap up the batch geometry in a `PIXI.Geometry` object.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method build\n * @returns {PIXI.Geometry} batch geometry\n */\n\n/**\n * This is used to return a batch geometry so it can be pooled and reused in a future `build()`\n * call.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method release\n * @param {PIXI.Geometry} geom\n */\n\n/**\n * Factory class that generates the geometry for a whole batch by feeding on\n * the individual display-object geometries. This factory is reusable, i.e. you\n * can build another geometry after a {@link build} call.\n *\n * **Optimizations:** To speed up geometry generation, this compiles an optimized\n * packing function that pushes attributes without looping through the attribute\n * redirects.\n *\n * **Default Format:** If you are not using a custom draw-call issuer, then\n * the batch geometry must have an interleaved attribute data buffer and one\n * index buffer.\n *\n * **Customization:** If you want to customize the batch geometry, then you must\n * also define your draw call issuer. This is not supported by pixi-batch-render\n * but is work-in-progress.\n *\n * @memberof PIXI.brend\n * @class\n * @implements PIXI.brend.IBatchGeometryFactory\n */\nexport class BatchGeometryFactory\n{\n    _targetCompositeAttributeBuffer: PIXI.ViewableBuffer;\n    _targetCompositeIndexBuffer: Uint16Array;\n    _aIndex: number;\n    _iIndex: number;\n\n    _attribRedirects: AttributeRedirect[];\n    _indexProperty: string;\n    _vertexCountProperty: string | number;\n    _vertexSize: number;\n    _texturePerObject: number;\n\n    textureId: number;\n\n    protected _aBuffers: PIXI.ViewableBuffer[];\n    protected _iBuffers: Uint16Array[];\n\n    protected _geometryPool: Array<PIXI.Geometry>;\n\n    _geometryMerger: (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void;\n\n    /**\n     * @param {PIXI.brend.AttributeRedirect[]} attributeRedirects\n     * @param {string} indexProperty - property where indicies are kept; null/undefined if not required.\n     * @param {string | number} vertexCountProperty - property where no. of vertices for each object\n     *  are kept. This could also be a constant.\n     * @param {number} vertexSize - vertex size, calculated by default. This should exclude the vertex attribute\n     * @param {number} texturePerObject - no. of textures per object\n     */\n    constructor(\n        attribRedirects: AttributeRedirect[],\n        indexProperty: string,\n        vertexCountProperty: string | number,\n        vertexSize = AttributeRedirect.vertexSizeFor(attribRedirects),\n        texturePerObject: number)\n    {\n        vertexSize += texturePerObject * 4;// texture indices are also passed\n\n        this._targetCompositeAttributeBuffer = null;\n        this._targetCompositeIndexBuffer = null;\n        this._aIndex = 0;\n        this._iIndex = 0;\n\n        this._attribRedirects = attribRedirects;\n        this._indexProperty = indexProperty;\n        this._vertexCountProperty = vertexCountProperty;\n        this._vertexSize = vertexSize;\n        this._texturePerObject = texturePerObject;\n\n        this._aBuffers = [];// @see _getAttributeBuffer\n        this._iBuffers = [];// @see _getIndexBuffer\n\n        /**\n         * Batch geometries that can be reused.\n         *\n         * @member {PIXI.Geometry}\n         * @protected\n         * @see PIXI.brend.IBatchGeometryFactory#release\n         */\n        this._geometryPool = [];\n    }\n\n    /**\n     * This is the currently active composite attribute\n     * buffer. It may contain garbage in unused locations.\n     *\n     * @member {PIXI.ViewableBuffer}\n     */\n    get compositeAttributes(): PIXI.ViewableBuffer\n    {\n        return this._targetCompositeAttributeBuffer;\n    }\n\n    /**\n     * This is the currently active composite index\n     * buffer. It may contain garbage in unused locations.\n     *\n     * It will be `null` if `indexProperty` was not given.\n     *\n     * @member {Uint16Array}\n     */\n    get compositeIndices(): Uint16Array\n    {\n        return this._targetCompositeIndexBuffer;\n    }\n\n    /**\n     * Ensures this factory has enough space to buffer the given number of vertices\n     * and indices. This should be called before feeding display-objects from the\n     * batch.\n     *\n     * @param {number} verticesBatched\n     * @param {number} indiciesBatched\n     */\n    init(verticesBatched: number, indiciesBatched?: number): void\n    {\n        this._targetCompositeAttributeBuffer = this.getAttributeBuffer(verticesBatched);\n\n        if (this._indexProperty)\n        {\n            this._targetCompositeIndexBuffer = this.getIndexBuffer(indiciesBatched);\n        }\n\n        this._aIndex = this._iIndex = 0;\n    }\n\n    /**\n     * Append's the display-object geometry to this batch's geometry.\n     *\n     * @param {PIXI.DisplayObject} targetObject\n     * @param {number} textureId\n     */\n    append(targetObject: PIXI.DisplayObject, textureId: number): void\n    {\n        this.textureId = textureId;\n        this.geometryMerger(targetObject, this);\n    }\n\n    /**\n     * @override\n     * @returns {PIXI.Geometry} the generated batch geometry\n     */\n    build(): PIXI.Geometry\n    {\n        const geom: BatchGeometry = (this._geometryPool.pop() || new BatchGeometry(\n            this._attribRedirects, true, 'aInBatchID', this._texturePerObject)) as BatchGeometry;\n\n        // We don't really have to remove the buffers because BatchRenderer won't reuse\n        // the data in these buffers after the next build() call.\n        geom.attribBuffer.update(this._targetCompositeAttributeBuffer.rawBinaryData);\n        geom.indexBuffer.update(this._targetCompositeIndexBuffer);\n\n        return geom;\n    }\n\n    /**\n     * @param {PIXI.Geometry} geom - releases back the geometry to be reused. It is expected\n     *  that it is not used externally again.\n     * @override\n     */\n    release(geom: PIXI.Geometry): void\n    {\n        this._geometryPool.push(geom);\n    }\n\n    /**\n     * This lazy getter returns the geometry-merger function. This function\n     * takes one argument - the display-object to be appended to the batch -\n     * and pushes its geometry to the batch geometry.\n     *\n     * You can overwrite this property with a custom geometry-merger function\n     * if customizing `PIXI.brend.BatchGeometryFactory`.\n     *\n     * @member {PIXI.brend#IGeometryMerger}\n     */\n    protected get geometryMerger(): (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void\n    {\n        if (!this._geometryMerger)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this._geometryMerger = new GeometryMergerFactory(this).compile();\n        }\n\n        return this._geometryMerger;\n    }\n    // eslint-disable-next-line require-jsdoc\n    protected set geometryMerger(func: (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void)\n    {\n        this._geometryMerger = func;\n    }\n\n    /**\n     * Allocates an attribute buffer with sufficient capacity to hold `size` elements.\n     *\n     * @param {number} size\n     * @protected\n     */\n    protected getAttributeBuffer(size: number): PIXI.ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._aBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer\n                = new PIXI.ViewableBuffer(roundedSize * this._vertexSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Allocates an index buffer (`Uint16Array`) with sufficient capacity to hold `size` indices.\n     *\n     * @param size\n     * @protected\n     */\n    protected getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer\n                = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n}\n\n// GeometryMergerFactory uses these variable names.\nconst CompilerConstants = {\n    INDICES_OFFSET: '__offset_indices_',\n    FUNC_SOURCE_BUFFER: 'getSourceBuffer',\n\n    // Argument names for the geometryMerger() function.\n    packerArguments: [\n        'targetObject',\n        'factory',\n    ],\n};\n\n// This was intended to be an inner class of BatchGeometryFactory; however, due to\n// a bug in JSDoc, it was placed outside.\n// https://github.com/jsdoc/jsdoc/issues/1673\n\n// Factory for generating a geometry-merger function (which appends the geometry of\n// a display-object to the batch geometry).\nconst GeometryMergerFactory = class\n{\n    packer: BatchGeometryFactory;\n\n    // We need the BatchGeometryFactory for attribute redirect information.\n    constructor(packer: BatchGeometryFactory)\n    {\n        this.packer = packer;\n    }\n\n    compile(): (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void\n    {\n        const packer = this.packer;\n\n        // The function's body/code is placed here.\n        let packerBody = ``;\n\n        // Define __offset_${i}, the offset of each attribute in the display-object's\n        // geometry, __buffer_${i} the source buffer of the attribute data.\n        packer._attribRedirects.forEach((redirect, i) =>\n        {\n            packerBody += `\n                let __offset_${i} = 0;\n                const __buffer_${i} = (\n                    ${this._compileSourceBufferExpression(redirect, i)});\n            `;\n        });\n\n        // This loops through each vertex in the display-object's geometry and appends\n        // them (attributes are interleaved, so each attribute element is pushed per vertex)\n        packerBody += `\n            const compositeAttributes = factory._targetCompositeAttributeBuffer;\n            const compositeIndices = factory._targetCompositeIndexBuffer;\n            let aIndex = factory._aIndex;\n            let iIndex = factory._iIndex;\n            const textureId = factory.textureId;\n            const attributeRedirects = factory.attributeRedirects;\n\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;\n\n        // Eliminate offset conversion when adjacent attributes\n        // have similar source-types.\n        let skipReverseTransformation = false;\n\n        // Appends a vertice's attributes (inside the for-loop above).\n        for (let i = 0; i < packer._attribRedirects.length; i++)\n        {\n            const redirect = packer._attribRedirects[i];\n\n            /* Initialize adjsutedAIndex in terms of source type. */\n            if (!skipReverseTransformation)\n            {\n                packerBody += `\n                    adjustedAIndex = aIndex / ${this._sizeOf(i)};\n                `;\n            }\n\n            if (typeof redirect.size === 'number')\n            {\n                for (let j = 0; j < redirect.size; j++)\n                {\n                    packerBody += `\n                        ${redirect.type}View[adjustedAIndex++] =\n                            __buffer_${i}[__offset_${i}++];\n                    `;\n                }\n            }\n            else\n            {\n                packerBody += `\n                        ${redirect.type}View[adjustedAIndex++] =\n                            __buffer_${i};\n                `;\n            }\n\n            if (packer._attribRedirects[i + 1]\n                && (this._sizeOf(i + 1) !== this._sizeOf(i)))\n            {\n                packerBody += `\n                    aIndex = adjustedAIndex * ${this._sizeOf(i)};\n                `;\n            }\n            else\n            {\n                skipReverseTransformation = true;\n            }\n        }\n\n        if (skipReverseTransformation)\n        {\n            if (this._sizeOf(packer._attribRedirects.length - 1)\n                    !== 4)\n            {\n                packerBody += `\n                    aIndex = adjustedAIndex * ${this._sizeOf(\n        packer._attribRedirects.length - 1)}\n                `;\n                skipReverseTransformation = false;\n            }\n        }\n\n        if (packer._texturePerObject > 0)\n        {\n            if (packer._texturePerObject > 1)\n            {\n                if (!skipReverseTransformation)\n                {\n                    packerBody += `\n                        adjustedAIndex = aIndex / 4;\n                    `;\n                }\n\n                for (let k = 0; k < packer._texturePerObject; k++)\n                {\n                    packerBody += `\n                        float32View[adjustedAIndex++] = textureId[${k}];\n                    `;\n                }\n\n                packerBody += `\n                    aIndex = adjustedAIndex * 4;\n                `;\n            }\n            else if (!skipReverseTransformation)\n            {\n                packerBody += `\n                    float32View[aIndex] = textureId;\n                    aIndex += 4;\n                `;\n            }\n            else\n            {\n                packerBody += `\n                    float32View[adjustedAIndex++] = textureId;\n                    aIndex = adjustedAIndex * 4;\n                `;\n            }\n        }\n\n        /* Close the packing for-loop. */\n        packerBody += `}\n            ${this.packer._indexProperty\n        ? `const oldAIndex = this._aIndex;`\n        : ''}\n            this._aIndex = aIndex;\n        `;\n\n        if (this.packer._indexProperty)\n        {\n            packerBody += `\n                const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n                const indexCount\n                    = targetObject['${this.packer._indexProperty}'].length;\n\n                for (let j = 0; j < indexCount; j++)\n                {\n                    compositeIndices[iIndex++] = verticesBefore +\n                        targetObject['${this.packer._indexProperty}'][j];\n                }\n\n                this._iIndex = iIndex;\n            `;\n        }\n\n        // eslint-disable-next-line no-new-func\n        return new Function(\n            ...CompilerConstants.packerArguments,\n            packerBody) as\n        (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void;\n    }\n\n    // Returns an expression that fetches the attribute data source from\n    // targetObject (DisplayObject).\n    _compileSourceBufferExpression(redirect: Redirect, i: number): string\n    {\n        return (typeof redirect.source === 'string')\n            ? `targetObject['${redirect.source}']`\n            : `attributeRedirects[${i}].source(targetObject)`;\n    }\n\n    _compileVertexCountExpression(): string\n    {\n        if (!this.packer._vertexCountProperty)\n        {\n            // auto-calculate based on primary attribute\n            return `__buffer_0.length / ${\n                this.packer._attribRedirects[0].size}`;\n        }\n\n        return (\n            (typeof this.packer._vertexCountProperty === 'string')\n                ? `targetObject.${this.packer._vertexCountProperty}`\n                : `${this.packer._vertexCountProperty}`\n        );\n    }\n\n    _sizeOf(i: number): number\n    {\n        return PIXI.ViewableBuffer.sizeOf(\n            this.packer._attribRedirects[i].type);\n    }\n};\n\nexport default BatchGeometryFactory;\n","import * as PIXI from 'pixi.js';\n\nexport function resolveConstantOrProperty(targetObject: PIXI.DisplayObject, property: string | number): any\n{\n    return (typeof property === 'string')\n        ? targetObject[property]\n        : property;\n}\n\nexport default resolveConstantOrProperty;\n","import * as PIXI from 'pixi.js';\n\nexport function resolveFunctionOrProperty(targetObject: PIXI.DisplayObject, property: Function | string): any\n{\n    return (typeof property === 'string')\n        ? targetObject[property]\n        : property(targetObject);\n}\n\nexport default resolveFunctionOrProperty;\n","import { Batch } from './Batch';\nimport { BatchFactory } from './BatchGenerator';\nimport { BatchGeometryFactory } from './BatchGeometryFactory';\nimport * as PIXI from 'pixi.js';\nimport { resolveConstantOrProperty, resolveFunctionOrProperty } from './resolve';\nimport { AttributeRedirect } from './redirects/AttributeRedirect';\n\n/**\n * This object renderer renders multiple display-objects in batches. It can greatly\n * reduce the number of draw calls issued per frame.\n *\n * ## Batch Rendering Pipeline\n *\n * The batch rendering pipeline consists of the following stages:\n *\n * * **Display-object buffering**: Each display-object is kept in a buffer until it fills\n * up or a flush is required.\n *\n * * **Geometry compositing**: The geometries of each display-object are merged together\n * in one interleaved composite geometry.\n *\n * * **Batch accumulation**: In a sliding window, display-object batches are generated based\n * off of certain constraints like GPU texture units and the uniforms used in each display-object.\n *\n * * **Rendering**: Each batch is rendered in-order using `gl.draw*`. The textures and\n * uniforms of each display-object are uploaded as arrays.\n *\n * ## Shaders\n *\n * ### Shader templates\n *\n * Since the max. display-object count per batch is not known until the WebGL context is created,\n * shaders are generated at runtime by processing shader templates. A shader templates has \"%macros%\"\n * that are replaced by constants at runtime.\n *\n * ### Textures\n *\n * The batch renderer uploads textures in the `uniform sampler2D uSamplers[%texturesPerBatch%];`. The\n * `varying float vTextureId` defines the index into this array that holds the current display-object's\n * texture.\n *\n * ### Uniforms\n *\n * This renderer currently does not support customized uniforms for display-objects. This is a\n * work-in-progress feature.\n *\n * ## Learn more\n * This batch renderer uses the PixiJS object-renderer API to hook itself:\n *\n * 1. [PIXI.ObjectRenderer]{@link http://pixijs.download/release/docs/PIXI.ObjectRenderer.html}\n *\n * 2. [PIXI.AbstractBatchRenderer]{@link http://pixijs.download/release/docs/PIXI.AbstractBatchRenderer.html}\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.ObjectRenderer\n * @example\n * import * as PIXI from 'pixi.js';\n * import { BatchRendererPluginFactory } from 'pixi-batch-renderer';\n *\n * // Define the geometry of your display-object and create a BatchRenderer using\n * // BatchRendererPluginFactory. Register it as a plugin with PIXI.Renderer.\n * PIXI.Renderer.registerPlugin('ExampleBatchRenderer', BatchRendererPluginFactory.from(...));\n *\n * class ExampleObject extends PIXI.Container\n * {\n *     _render(renderer: PIXI.Renderer): void\n *     {\n *          // BatchRenderer will handle the whole rendering process for you!\n *          renderer.batch.setObjectRenderer(renderer.plugins['ExampleBatchRenderer']);\n *          renderer.plugins['ExampleBatchRenderer'].render(this);\n *     }\n * }\n */\nexport class BatchRenderer extends PIXI.ObjectRenderer\n{\n    _attributeRedirects: AttributeRedirect[];\n    _indexProperty: string;\n    _vertexCountProperty: string | number;\n    _textureProperty: string;\n    _texturePerObject: number;\n    _textureAttribute: string;\n    _stateFunction: Function;\n    _shaderFunction: Function;\n\n    _BatchGeneratorClass: typeof BatchFactory;\n    _batchGenerator: BatchFactory;\n\n    _geometryFactory: BatchGeometryFactory;\n    _geom: PIXI.Geometry;\n\n    _objectBuffer: PIXI.DisplayObject[];\n    _bufferedVertices: number;\n    _bufferedIndices: number;\n\n    _shader: PIXI.Shader;\n\n    _batchPool: Array<Batch>;\n    _batchCount: number;\n\n    MAX_TEXTURES: number;\n\n    /**\n     * Creates a batch renderer the renders display-objects with the described\n     * geometry.\n     *\n     * To register a batch-renderer plugin, you must use the API provided by\n     * `PIXI.brend.BatchRendererPluginFactory`.\n     *\n     * @param {PIXI.Renderer} renderer - renderer to attach to\n     * @param {PIXI.brend.AttributeRedirect[]} attributeRedirects\n     * @param {string | null} indexProperty\n     * @param {string | number} vertexCountProperty\n     * @param {string | null} textureProperty\n     * @param {number} texturePerObject\n     * @param {string} textureAttribute - name of texture-id attribute variable\n     * @param {Function} stateFunction - returns a {PIXI.State} for an object\n     * @param {Function} shaderFunction - generates a shader given this instance\n     * @param {PIXI.brend.GeometryPacker} [packer=new PIXI.brend.GeometryPacker]\n     * @param {Class} [BatchGeneratorClass=PIXI.brend.BatchGenerator]\n     * @see PIXI.brend.ShaderGenerator\n     */\n    constructor(// eslint-disable-line max-params\n        renderer: PIXI.Renderer,\n        attributeRedirects: AttributeRedirect[],\n        indexProperty: string,\n        vertexCountProperty: string | number,\n        textureProperty: string,\n        texturePerObject: number,\n        textureAttribute: string,\n        stateFunction: (renderer: BatchRenderer) => PIXI.State,\n        shaderFunction: (renderer: BatchRenderer) => PIXI.Shader,\n        packer = new BatchGeometryFactory(\n            attributeRedirects,\n            indexProperty,\n            vertexCountProperty, // auto-calculate\n            undefined,\n            texturePerObject,\n        ),\n        BatchGeneratorClass = BatchFactory,\n    )\n    {\n        super(renderer);\n\n        this._attributeRedirects = attributeRedirects;\n        this._indexProperty = indexProperty;\n        this._vertexCountProperty = vertexCountProperty;\n        this._textureProperty = textureProperty;\n        this._texturePerObject = texturePerObject;\n        this._textureAttribute = textureAttribute;\n        this._stateFunction = stateFunction;\n        this._shaderFunction = shaderFunction;\n\n        this._BatchGeneratorClass = BatchGeneratorClass;\n        this._batchGenerator = null;// @see this#contextChange\n\n        // Although the runners property is not a public API, it is required to\n        // handle contextChange events.\n        this.renderer.runners.contextChange.add(this);\n\n        // If the WebGL context has already been created, initialization requires a\n        // syntheic call to contextChange.\n        if (this.renderer.gl)\n        {\n            this.contextChange();\n        }\n\n        this._geometryFactory = packer;\n\n        this._geom = BatchRenderer.generateCompositeGeometry(\n            attributeRedirects,\n            !!indexProperty,\n            textureAttribute,\n            texturePerObject);\n\n        this._objectBuffer = [];\n        this._bufferedVertices = 0;\n        this._bufferedIndices = 0;\n        this._shader = null;\n\n        this._batchPool = [];// may contain garbage after _batchCount\n        this._batchCount = 0;\n    }\n\n    /**\n     * Internal method that is called whenever the renderer's WebGL context changes.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (PIXI.settings.PREFER_ENV === PIXI.ENV.WEBGL_LEGACY)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            this.MAX_TEXTURES = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                PIXI.settings.SPRITE_MAX_TEXTURES);\n        }\n\n        this._batchGenerator = new this._BatchGeneratorClass(\n            this._texturePerObject, this.MAX_TEXTURES,\n            this._textureProperty, true); // NOTE: Force texture reduction\n\n        if (!this._batchGenerator.enableTextureReduction)\n        {\n            throw new Error('PIXI.brend.BatchRenderer does not support '\n                    + 'batch generation without texture reduction enabled.');\n        }\n    }\n\n    /**\n     * This is an internal method. It ensures that the batch renderer is ready\n     * to start buffering display-objects. This is automatically invoked by the\n     * renderer's batch system.\n     *\n     * @override\n     */\n    start(): void\n    {\n        this._objectBuffer.length = 0;\n        this._bufferedVertices = 0;\n        this._bufferedIndices = 0;\n\n        this._shader = this._shaderFunction(this);\n\n        if (this._shader.uniforms.uSamplers)\n        {\n            this._shader.uniforms.uSamplers\n                = BatchRenderer.generateTextureArray(this.MAX_TEXTURES);\n        }\n\n        this.renderer.shader.bind(this._shader, false);\n    }\n\n    /**\n     * Adds the display-object to be rendered in a batch.\n     *\n     * @param {PIXI.DisplayObject} displayObject\n     * @override\n     */\n    render(displayObject: PIXI.DisplayObject): void\n    {\n        this._objectBuffer.push(displayObject);\n\n        this._bufferedVertices += this._vertexCountFor(displayObject);\n\n        if (this._indexProperty)\n        {\n            this._bufferedIndices += resolveConstantOrProperty(\n                displayObject, this._indexProperty).length;\n        }\n    }\n\n    /**\n     * Forces buffered display-objects to be rendered immediately. This should not\n     * be called unless absolutely necessary like the following scenarios:\n     *\n     * * before directly rendering your display-object, to preserve render-order.\n     *\n     * * to do a nested render pass (calling `Renderer#render` inside a `render` method)\n     *   because the PixiJS renderer is not re-entrant.\n     *\n     * @override\n     */\n    flush(): void\n    {\n        const {\n            _batchGenerator: batchGenerator,\n            _geom: geom,\n            _geometryFactory: geometryFactory,\n            renderer,\n            _stateFunction: stateFunction,\n            _textureProperty: textureProperty,\n            _texturePerObject: texturePerObject,\n        } = this;\n\n        const gl = renderer.gl;\n        const buffer = this._objectBuffer;\n        const bufferLength = buffer.length;\n\n        this._batchCount = 0;\n        geometryFactory.init(this._bufferedVertices, this._bufferedIndices);\n\n        let batchStart = 0;\n\n        // Loop through display-objects and create batches\n        for (let objectIndex = 0; objectIndex < bufferLength;)\n        {\n            const target = buffer[objectIndex];\n            const wasPut = batchGenerator.put(target,\n                resolveFunctionOrProperty(target, stateFunction));\n\n            if (!wasPut)\n            {\n                batchGenerator.finalize(this._newBatch(batchStart));\n                batchStart = objectIndex;\n            }\n            else\n            {\n                ++objectIndex;\n            }\n        }\n\n        // Generate the last batch, if required.\n        if (batchGenerator._batchBuffer.length !== 0)\n        {\n            batchGenerator.finalize(this._newBatch(batchStart));\n        }\n\n        // Pack each object into the composite geometry. This is done\n        // after batching, so that texture-ids are generated.\n        let textureId = this._texturePerObject === 1\n            ? 0\n            : new Array(texturePerObject);\n\n        for (let i = 0; i < this._batchCount; i++)// loop-per(batch)\n        {\n            const batch = this._batchPool[i];\n            const batchBuffer = batch.batchBuffer;\n            const batchLength = batchBuffer.length;\n            const uidMap = batch.uidMap;\n\n            let vertexCount = 0;// eslint-disable-line\n            let indexCount = 0;\n\n            for (let j = 0; j < batchLength; j++)// loop-per(targetObject)\n            {\n                const targetObject = batchBuffer[j];\n\n                if (this._indexProperty)\n                {\n                    indexCount += resolveConstantOrProperty(\n                        targetObject, this._indexProperty).length;\n                }\n                else\n                {\n                    vertexCount += resolveConstantOrProperty(\n                        targetObject, this._vertexCountProperty);\n                }\n\n                // externally-defined properties for draw calls\n                batch.$vertexCount = vertexCount;\n                batch.$indexCount = indexCount;\n\n                const tex = targetObject[textureProperty];\n\n                let texUID;\n\n                if (texturePerObject === 1)\n                {\n                    texUID = tex.baseTexture\n                        ? tex.baseTexture.uid\n                        : tex.uid;\n\n                    textureId = uidMap[texUID];\n                }\n                else\n                {\n                    let _tex;\n\n                    for (let k = 0; k < tex.length; k++)\n                    {\n                        _tex = tex[k];\n\n                        texUID = _tex.BaseTexture\n                            ? _tex.baseTexture.uid\n                            : _tex.uid;\n\n                        textureId[k] = uidMap[texUID];\n                    }\n                }\n\n                geometryFactory.append(targetObject, textureId);\n            }\n        }\n\n        // Upload the geometry\n        geom.$buffer.update(geometryFactory.compositeAttributes.float32View);\n        geom.getIndex().update(geometryFactory.compositeIndices);\n        renderer.geometry.bind(geom);\n        renderer.geometry.updateBuffers();\n\n        // Now draw each batch\n        for (let i = 0; i < this._batchCount; i++)\n        {\n            const batch = this._batchPool[i];\n\n            batch.upload(renderer);\n\n            if (this._indexProperty)\n            {\n                gl.drawElements(gl.TRIANGLES,\n                    batch.$indexCount,\n                    gl.UNSIGNED_SHORT,\n                    batch.geometryOffset * 2);// * 2 cause Uint16 indices\n            }\n            else\n            {\n                gl.drawArrays(gl.TRIANGLES,\n                    batch.geometryOffset,\n                    batch.$vertexCount);// TODO: *vertexSize\n            }\n\n            batch.reset();\n        }\n    }\n\n    /**\n     * Internal method that stops buffering of display-objects and flushes any existing\n     * buffers.\n     *\n     * @override\n     */\n    stop(): void\n    {\n        if (this._bufferedVertices)\n        {\n            this.flush();\n        }\n    }\n\n    protected _newBatch(batchStart: number): Batch\n    {\n        if (this._batchCount === this._batchPool.length)\n        {\n            const batch = new Batch(batchStart);\n\n            this._batchPool.push(batch);\n            ++this._batchCount;\n\n            return batch;\n        }\n\n        const batch = this._batchPool[this._batchCount++];\n\n        batch.reset();\n        batch.geometryOffset = batchStart;\n\n        return batch;\n    }\n\n    protected _vertexCountFor(targetObject: PIXI.DisplayObject): number\n    {\n        return (this._vertexCountProperty)\n            ? resolveConstantOrProperty(targetObject, this._vertexCountProperty)\n            : resolveFunctionOrProperty(targetObject,\n                this._attributeRedirects[0].source).length\n                    / (this._attributeRedirects[0].size as number);\n    }\n\n    /**\n     * Constructs an interleaved geometry that can be used to upload a whole buffer\n     * of display-object primitives at once.\n     *\n     * @private\n     * @param {Array<PIXI.brend.AttributeRedirect>} attributeRedirects\n     * @param {boolean} hasIndex - whether to include an index property\n     * @param {string} textureAttribute - name of the texture-id attribute\n     * @param {number} texturePerObject - no. of textures per object\n     */\n    static generateCompositeGeometry(\n        attributeRedirects: AttributeRedirect[],\n        hasIndex: boolean,\n        textureAttribute: string,\n        texturePerObject: number,\n    ): PIXI.Geometry\n    {\n        const geom = new PIXI.Geometry();\n        const attributeBuffer = new PIXI.Buffer(null, false, false);\n        const indexBuffer = hasIndex ? new PIXI.Buffer(null, false, true) : null;\n\n        attributeRedirects.forEach((redirect) =>\n        {\n            const {\n                glslIdentifer, glType, glSize,\n                normalize,\n            } = redirect;\n\n            geom.addAttribute(glslIdentifer, attributeBuffer,\n                glSize, normalize, glType);\n        });\n\n        if (textureAttribute && texturePerObject > 0)\n        {\n            geom.addAttribute(textureAttribute, attributeBuffer,\n                texturePerObject, true, PIXI.TYPES.FLOAT);\n        }\n\n        if (hasIndex)\n        {\n            geom.addIndex(indexBuffer);\n        }\n\n        geom.$buffer = attributeBuffer;\n\n        // $buffer is attributeBuffer\n        // getIndex() is ?indexBuffer\n        return geom;\n    }\n\n    /**\n     * @private\n     * @param {number} count\n     */\n    static generateTextureArray(count: number): Int32Array\n    {\n        const array = new Int32Array(count);\n\n        for (let i = 0; i < count; i++)\n        {\n            array[i] = i;\n        }\n\n        return array;\n    }\n}\n\nexport default BatchRenderer;\n","import * as PIXI from 'pixi.js';\nimport BatchRenderer from './BatchRenderer';\n\n// JavaScript is stupid enough not to have a replaceAll\n// in String. This is a temporary solution and we should\n// depend on an actually polyfill.\nfunction _replaceAll(target: string, search: string, replacement: string): string\n{\n    return target.replace(new RegExp(search, 'g'), replacement);\n}\n\nfunction injectTexturesPerBatch(batchRenderer: BatchRenderer): string\n{\n    return `${batchRenderer.MAX_TEXTURES}`;\n}\n\n/**\n * Exposes an easy-to-use API for generating a shader function\n * for batch rendering.\n *\n * You are required to provide an injector map, which maps\n * macros to functions that return a string value for those\n * macros given a renderer.\n *\n * By default, only one injector is used - the textures per\n * batch `%texturesPerBatch%` macro. This is replaced by\n * the number of textures passed to the `uSamplers` textures\n * uniform.\n *\n * @memberof PIXI.brend\n * @class\n */\nclass ShaderGenerator\n{\n    protected _vertexShaderTemplate: string;\n    protected _fragmentShaderTemplate: string;\n    protected _uniforms: any;\n    protected _templateInjectors: any;\n\n    protected disableVertexShaderTemplate: boolean;\n\n    protected _cache: any;\n    protected _cState: any;\n\n    /**\n     * WARNING: Do not pass `uSamplers` in your uniforms. They\n     *  will be added to your shader instance directly.\n     *\n     * @param {string} vertexShaderTemplate\n     * @param {string} fragmentShaderTemplate\n     * @param {UniformGroup | Map<string, object>} uniforms\n     * @param {Object.<String, PIXI.brend.InjectorFunction>} [templateInjectors]\n     * @param {boolean} [disableVertexShaderTemplate=true] - turn off (true)\n     *      if you aren't using macros in the vertex shader\n     */\n    constructor(\n        vertexShaderTemplate: string,\n        fragmentShaderTemplate: string,\n        uniforms = {},\n        templateInjectors = {\n            '%texturesPerBatch%': injectTexturesPerBatch,\n        },\n        disableVertexShaderTemplate = true,\n    )\n    {\n        if (!templateInjectors['%texturesPerBatch%'])\n        {\n            templateInjectors['%texturesPerBatch%'] = injectTexturesPerBatch;\n        }\n\n        /** @protected */\n        this._vertexShaderTemplate = vertexShaderTemplate;\n        /** @protected */\n        this._fragmentShaderTemplate = fragmentShaderTemplate;\n        /** @protected */\n        this._uniforms = uniforms;\n        /** @protected */\n        this._templateInjectors = templateInjectors;\n\n        /**\n         * Disable vertex shader templates to speed up shader\n         * generation.\n         *\n         * @member {Boolean}\n         */\n        this.disableVertexShaderTemplate = disableVertexShaderTemplate;\n\n        /**\n         * Maps the stringifed state of the batch renderer to the\n         * generated shader.\n         *\n         * @private\n         * @member {Object.<String, PIXI.Shader>}\n         */\n        this._cache = {};\n\n        /**\n         * Unstringifed current state of the batch renderer.\n         *\n         * @private\n         * @member {Object.<String, String>}\n         * @see {PIXI.brend.ShaderGenerator#_generateInjectorBasedState}\n         */\n        this._cState = null;\n    }\n\n    /**\n     * @return shader function that can be given to the batch renderer\n     */\n    generateFunction(): (brend: BatchRenderer) => PIXI.Shader\n    {\n        return (batchRenderer: BatchRenderer): PIXI.Shader =>\n        {\n            const stringState = this._generateInjectorBasedState(batchRenderer);\n            const cachedShader = this._cache[stringState];\n\n            if (cachedShader)\n            {\n                return cachedShader;\n            }\n\n            return this._generateShader(stringState);\n        };\n    }\n\n    protected _generateInjectorBasedState(batchRenderer: BatchRenderer): string\n    {\n        let state = '';\n        const cState = this._cState = {};\n\n        for (const injectorMacro in this._templateInjectors)\n        {\n            const val = this._templateInjectors[injectorMacro](batchRenderer);\n\n            state += val;\n            cState[injectorMacro] = val;\n        }\n\n        return state;\n    }\n\n    protected _generateShader(stringState: string): PIXI.Shader\n    {\n        let vertexShaderTemplate = this._vertexShaderTemplate.slice(0);\n\n        let fragmentShaderTemplate = this._fragmentShaderTemplate.slice(0);\n\n        for (const injectorTemplate in this._cState)\n        {\n            if (!this.disableVertexShaderTemplate)\n            {\n                vertexShaderTemplate = _replaceAll(vertexShaderTemplate,\n                    injectorTemplate, this._cState[injectorTemplate]);\n            }\n\n            fragmentShaderTemplate = _replaceAll(fragmentShaderTemplate,\n                injectorTemplate, this._cState[injectorTemplate]);\n        }\n\n        const shader = PIXI.Shader.from(vertexShaderTemplate,\n            fragmentShaderTemplate, this._uniforms);\n\n        this._cache[stringState] = shader;\n\n        return shader;\n    }\n}\n\nexport { ShaderGenerator };\nexport default ShaderGenerator;\n","import { BatchRenderer } from './BatchRenderer';\nimport { AttributeRedirect } from './redirects/AttributeRedirect';\nimport BatchGeometryFactory from './BatchGeometryFactory';\nimport BatchFactory from './BatchGenerator';\n\nimport * as PIXI from 'pixi.js';\n\n// Geometry+Textures is the standard pipeline in Pixi's AbstractBatchRenderer.\ninterface IBatchRendererStdOptions\n{\n    attribSet: AttributeRedirect[];\n    vertexCountProperty: string | number;\n    indexCountProperty: string;\n    textureProperty: string;\n    texturePerObject: number;\n    inBatchIdAttrib: string;\n    stateFunction: (brend: BatchRenderer) => any;\n    shaderFunction: (brend: BatchRenderer) => any;\n    geometryFactory: BatchGeometryFactory;\n    BatchFactoryClass: typeof BatchFactory;\n    BatchRendererClass: typeof BatchRenderer;\n}\n\n/**\n * Factory class for creating a batch-renderer.\n *\n * @memberof PIXI.brend\n * @class\n * @example\n *  // Define the geometry of Sprite.\n *  const attribSet = [\n *      // Sprite vertexData contains global coordinates of the corners\n *      new AttributeRedirect({\n *          source: 'vertexData',\n *          attrib: 'aVertex',\n *          type: 'float32',\n *          size: 2,\n *          glType: PIXI.TYPES.FLOAT,\n *          glSize: 2,\n *      }),\n *      // Sprite uvs contains the normalized texture coordinates for each corner/vertex\n *      new AttributeRedirect({\n *          source: 'uvs',\n *          attrib: 'aTextureCoord',\n *          type: 'float32',\n *          size: 2,\n *          glType: PIXI.TYPES.FLOAT,\n *          glSize: 2,\n *      }),\n *  ];\n *\n *  const shaderFunction = new ShaderGenerator(// 1. vertexShader\n *  `\n *  attribute vec2 aVertex;\n *  attribute vec2 aTextureCoord;\n *  attribute float aTextureId;\n *\n *  varying float vTextureId;\n *  varying vec2 vTextureCoord;\n *\n *  uniform mat3 projectionMatrix;\n *\n *  void main() {\n *      gl_Position = vec4((projectionMatrix * vec3(aVertex, 1)).xy, 0, 1);\n *      vTextureId = aTextureId;\n *      vTextureCoord = aTextureCoord;\n *  }\n *  `,\n *  `\n *  uniform sampler2D uSamplers[%texturesPerBatch%];\n *  varying float vTextureId;\n *  varying vec2 vTextureCoord;\n *\n *  void main(void){\n *      vec4 color;\n *\n *      // get color, which is the pixel in texture uSamplers[vTextureId] @ vTextureCoord\n *      for (int k = 0; k < %texturesPerBatch%; ++k) {\n *          if (int(vTextureId) == k) {\n *              color = texture2D(uSamplers[k], vTextureCoord);\n *              break;\n *          }\n *      }\n *\n *      gl_FragColor = color;\n *  }\n *  `,\n *  {// we don't use any uniforms except uSamplers, which is handled by default!\n *  },\n *  // no custom template injectors\n *  // disable vertex shader macros by default\n *  ).generateFunction()\n *\n *  // Produce the SpriteBatchRenderer class!\n *  const SpriteBatchRenderer = BatchRendererPluginFactory.from({\n *      attribSet,\n *      indexCountProperty: 'indices',\n *      textureProperty: 'texture',\n *      texturePerObject: 1,\n *      inBatchIdAttrib: 'aTextureId',\n *      stateFunction: () => PIXI.State.for2d(), // default\n *      shaderFunction\n *  });\n *\n *  PIXI.Renderer.registerPlugin('customBatch', SpriteBatchRenderer);\n *\n *  // Sprite will render using SpriteBatchRenderer instead of default PixiJS\n *  // batch renderer. Instead of targetting PIXI.Sprite, you can write a batch\n *  // renderer for a custom display-object too! (See main page for that example!)\n *  const exampleSprite = PIXI.Sprite.from('./asset/example.png');\n *  exampleSprite.pluginName = 'customBatch';\n *  exampleSprite.width = 128;\n *  exampleSprite.height = 128;\n */\nexport class BatchRendererPluginFactory\n{\n    /**\n     * Generates a fully customized `BatchRenderer` that aggregates primitives\n     * and textures. This is useful for non-uniform based display-objects.\n     *\n     * @param {object} options\n     * @param {PIXI.brend.AttributeRedirect[]} options.attribSet - set of geometry attributes\n     * @param {string | Array<number>} options.indexCountProperty - no. of indices on display-object\n     * @param {string | number} options.vertexCountProperty - no. of vertices on display-object\n     * @param {string} options.textureProperty - textures used in display-object\n     * @param {number} options.texturePerObject - no. of textures used per display-object\n     * @param {string} options.inBatchIdAttrib - used to find texture for each display-object (index into array)\n     * @param {string | Function}[options.stateFunction= ()=>PIXI.State.for2d()] - callback that finds the WebGL\n     *  state required for display-object shader\n     * @param {Function} shaderFunction - shader generator function\n     * @param {PIXI.brend.BatchGeometryFactory}[options.geometryFactory]\n     * @param {Class} [options.BatchFactoryClass] - custom batch factory class\n     * @param {Class} [BatchRendererClass] - custom batch renderer class\n     * @static\n     */\n    static from(options: IBatchRendererStdOptions): typeof BatchRenderer\n    {\n        return class extends (options.BatchRendererClass || BatchRenderer)\n        {\n            constructor(renderer: PIXI.Renderer)\n            {\n                super(renderer,\n                    options.attribSet,\n                    options.indexCountProperty,\n                    options.vertexCountProperty,\n                    options.textureProperty,\n                    options.texturePerObject,\n                    options.inBatchIdAttrib,\n                    options.stateFunction || ((): PIXI.State => PIXI.State.for2d()),\n                    options.shaderFunction,\n                    options.geometryFactory,\n                    options.BatchFactoryClass);\n            }\n        };\n    }\n}\n\nexport default BatchRendererPluginFactory;\n"],"names":["Redirect","[object Object]","source","glslIdentifer","this","AttributeRedirect","options","super","attrib","type","size","properSize","glType","glSize","normalize","attributeRedirects","reduce","acc","redirect","PIXI.ViewableBuffer","sizeOf","BatchFactory","textureIncrement","textureLimit","textureProperty","enableTextureReduction","_state","_textureIncrement","_textureLimit","_textureProperty","_batchBuffer","_textureBuffer","_textureBufferLength","_textureIndexedBuffer","_textureIndexMap","_putTexture","_putOnlyTexture","_putTextureArray","_putTextureWithoutReduction","_putTextureArrayWithoutReduction","targetObject","state","data","onPut","push","batch","batchBuffer","textureBuffer","uidMap","texture","baseTexture","uid","index","textureArray","deltaBufferLength","i","length","Batch","geometryOffset","renderer","forEach","tex","bind","set","BatchGeometry","PIXI.Geometry","hasIndex","textureAttribute","texturePerObject","attributeBuffer","PIXI.Buffer","indexBuffer","addAttribute","PIXI.TYPES","FLOAT","addIndex","attribBuffer","BatchGeometryFactory","attribRedirects","indexProperty","vertexCountProperty","vertexSize","vertexSizeFor","_targetCompositeAttributeBuffer","_targetCompositeIndexBuffer","_aIndex","_iIndex","_attribRedirects","_indexProperty","_vertexCountProperty","_vertexSize","_texturePerObject","_aBuffers","_iBuffers","_geometryPool","compositeAttributes","compositeIndices","verticesBatched","indiciesBatched","getAttributeBuffer","getIndexBuffer","textureId","geometryMerger","geom","pop","update","rawBinaryData","_geometryMerger","GeometryMergerFactory","compile","func","roundedP2","PIXI.utils","nextPow2","Math","ceil","roundedSizeIndex","log2","roundedSize","buffer","Uint16Array","CompilerConstants","INDICES_OFFSET","FUNC_SOURCE_BUFFER","packerArguments","packer","packerBody","_compileSourceBufferExpression","_compileVertexCountExpression","skipReverseTransformation","_sizeOf","j","k","Function","resolveConstantOrProperty","property","resolveFunctionOrProperty","BatchRenderer","PIXI.ObjectRenderer","stateFunction","shaderFunction","undefined","BatchGeneratorClass","_attributeRedirects","_textureAttribute","_stateFunction","_shaderFunction","_BatchGeneratorClass","_batchGenerator","runners","contextChange","add","gl","_geometryFactory","_geom","generateCompositeGeometry","_objectBuffer","_bufferedVertices","_bufferedIndices","_shader","_batchPool","_batchCount","PIXI.settings","PREFER_ENV","PIXI.ENV","WEBGL_LEGACY","MAX_TEXTURES","min","getParameter","MAX_TEXTURE_IMAGE_UNITS","SPRITE_MAX_TEXTURES","Error","uniforms","uSamplers","generateTextureArray","shader","displayObject","_vertexCountFor","batchGenerator","geometryFactory","bufferLength","init","batchStart","objectIndex","target","put","finalize","_newBatch","Array","batchLength","vertexCount","indexCount","$vertexCount","$indexCount","texUID","_tex","BaseTexture","append","$buffer","float32View","getIndex","geometry","updateBuffers","upload","drawElements","TRIANGLES","UNSIGNED_SHORT","drawArrays","reset","flush","count","array","Int32Array","_replaceAll","search","replacement","replace","RegExp","injectTexturesPerBatch","batchRenderer","BatchRendererClass","attribSet","indexCountProperty","inBatchIdAttrib","PIXI.State","for2d","BatchFactoryClass","vertexShaderTemplate","fragmentShaderTemplate","templateInjectors","%texturesPerBatch%","disableVertexShaderTemplate","_vertexShaderTemplate","_fragmentShaderTemplate","_uniforms","_templateInjectors","_cache","_cState","stringState","_generateInjectorBasedState","cachedShader","_generateShader","cState","injectorMacro","val","slice","injectorTemplate","PIXI.Shader","from"],"mappings":"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"}