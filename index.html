<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>PixiJS Batch Rendering Library API Documentation</title>
    
    <meta name="description" content="Documentation for pixi-batch-renderer library" />
    
        <meta name="keywords" content="docs, documentation, pixi, pixijs, renderer, html5, javascript, jsdoc" />
        <meta name="keyword" content="docs, documentation, pixi, pixijs, renderer, html5, javascript, jsdoc" />
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Libre+Franklin:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/main.css">

    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"default":{"outputSourceFiles":true},"applicationName":"pixi-batch-renderer","footer":"Made with ♥ by Shukant Pal","copyright":"Copyright © 2019 Shukant Pal","disqus":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"PixiJS Batch Rendering Library API Documentation","description":"Documentation for pixi-batch-renderer library","keyword":"docs, documentation, pixi, pixijs, renderer, html5, javascript, jsdoc"},"linenums":true,"sort":false};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">pixi-batch-renderer</a></h3>
    <button id="menuToggle" class="btn btn-link btn-lg menu-toggle">
        <span class="glyphicon glyphicon-menu-hamburger"></span>
    </button>
    <div class="search">
        <input id="search" type="text" class="form-control input-md" placeholder="Search...">
    </div>
    <ul class="list">
    
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="index.html">Index</h1>
        


    


    <h3> </h3>








    




    <section>
        <article class="readme content-size"><p><a target="_blank" href="https://www.jsdelivr.com/package/npm/pixi-batch-renderer-alpha"><img src="https://data.jsdelivr.com/v1/package/npm/pixi-batch-renderer-alpha/badge" alt=""></a></p>
<h1>PixiJS Batch Rendering Library</h1>
<p><code>pixi-batch-renderer</code> is a PixiJS plugin that allows you to add batch rendering to your custom display objects. I have documented each class in the <code>PIXI.brend</code> namespace.</p>
<h2>Concepts</h2>
<p><a target="_blank" href="https://medium.com/swlh/inside-pixijs-batch-rendering-system-fad1b466c420">Batch rendering</a> objects involves aggregating them into groups/batches and rendering them together with one WebGL draw call. PixiJS supports batch rendering its internal display objects - <code>PIXI.Sprite</code>, <code>PIXI.Graphics</code>, and <code>PIXI.Mesh</code>. However, it is difficult to extend that to custom-built display objects; it wasn't designed as an exposable API.</p>
<p>This library builds upon the same concept and is designed for maximum flexibility. It still uses PixiJS's batch system - a stub that enables objects to be rendered asynchronously, without loosing the order of rendering. To understand how it works, understanding these things are helpful:</p>
<ul>
<li>
<p><strong>Attribute Redirects</strong>: An attribute redirect is a data-object that tells <code>pixi-batch-renderer</code> how it will transform your object into a set of shader attributes.</p>
</li>
<li>
<p><strong>Index Property</strong>: If you use indices, this will be property on your display object that holds those indices. It could also be a constant array, rather than a property on each object.</p>
</li>
<li>
<p><strong>State Function</strong>: This function/property tells the batch renderer what WebGL state is required to render a display-object. It is optional if you're display objects use the default state (<code>PIXI.State.for2d()</code>).</p>
</li>
<li>
<p><strong>Shader Function</strong>: This function generates the shader to render whole batches. It takes one argument - the batch renderer
that will use the shader. You can use the <code>BatchShaderFactory#derive()</code> API for create one.</p>
</li>
</ul>
<h3>New features</h3>
<ul>
<li>
<p><strong>Shader Templates</strong>: The <code>BatchShaderFactory</code> allows you to write shader &quot;templates&quot; containing <code>%macros%</code>. At runtime, you
can replace these macros based with another expression. For example, the (built-in) <code>%texturesPerBatch%</code> macro is set to the
no. of textures units in the GPU.</p>
</li>
<li>
<p><strong>Custom uniforms</strong>: [Experimental] You can also use uniforms in the batch shader; however, this might reduce the batching
efficiency if most batchable display-objects have different values for uniforms (because then they can't be batched together).</p>
</li>
<li>
<p><strong>Modular architecture</strong>: With the modular architecture of this library, you change the behaviour of any component. The
geometry composition, batch generation, and drawing stages are componentized and can be modified by providing a custom
implementation to <code>BatchRendererPluginFactory.from</code>.</p>
</li>
</ul>
<h3>Caveat with filtered/masked objects</h3>
<p>Before rendering itself, a <code>PIXI.Container</code> with filters or a mask will flush the batch renderer and will not batch itself. This
is because the PixiJS batch renderer cannot batch filtered and masked objects. Although this does not break pixi-batch-renderer,
it does reduce batching-efficiency. If you want to create a batch renderer that will batch filtered and masked objects too, your display-object must override <code>render</code> (<strong>however, you will have to derive your own batch renderer class for that</strong>):</p>
<pre class="prettyprint source"><code>render(renderer: PIXI.Renderer): void
{
  // If you registered the batch renderer as a plugin &quot;pluginName&quot;, then replace &lt;BatchRenderer> with
  // renderer.plugins.pluginName
  renderer.setObjectRenderer(&lt;BatchRenderer>);
  &lt;BatchRenderer>.render(this);

  for (let i = 0, j = this.children.length; i &lt; j; i++)
  {
      this._children.render(renderer);
  }
}
</code></pre>
<h1>Usage</h1>
<h3>Standard Pipeline</h3>
<p>For most use cases, <code>PIXI.brend.BatchRendererPluginFactory</code> is all you'll need from this library. You need to do these three things:</p>
<ol>
<li>
<p><strong>Generate the plugin class using <code>PIXI.brend.BatchRendererPluginFactory.from</code></strong></p>
</li>
<li>
<p><strong>Register the plugin with PixiJS's WebGL renderer</strong></p>
</li>
<li>
<p><strong>Make your custom display object defer its rendering to your plugin</strong></p>
</li>
</ol>
<p>An example implementation would look like:</p>
<pre class="prettyprint source lang-js"><code>import * as PIXI from 'pixi.js';
import { AttributeRedirect, BatchRendererPluginFactory, BatchShaderFactory } from 'pixi-batch-renderer';

// ExampleFigure has two attributes: aVertex and aTextureCoord. They come from the
// vertices and uvs properties in this object. The indices are in the indices property.
class ExampleFigure extends PIXI.Container
{
  _render(renderer)
  {
    this.vertices = [x0,y0, x1,y1, x2,y2, ..., xn,yn];// variable number of vertices
    this.uvs = [u0,v0, u1,v1, u2, v2, ..., un,yn];// however, all other attributes must have equal length
    this.texture = PIXI.Texture.from(&quot;url:example&quot;);

    this.indices = [0, 1, 2, ..., n];// we could also tell our batch renderer to not use indices too :)

    renderer.setObjectRenderer(renderer.plugins[&quot;ExampleRenderer&quot;]);
    renderer.plugins[&quot;ExampleRenderer&quot;].render(this);
  }
}

// Define the geometry of ExampleFigure.
const attribSet = [
  new AttributeRedirect({
      source: &quot;vertices&quot;, 
      attrib: &quot;aVertex&quot;, 
      type: 'float32', 
      size: 2, 
      glType: PIXI.TYPES.FLOAT, 
      glSize: 2
  }),
  new AttributeRedirect({
      source: &quot;uvs&quot;, 
      attrib: &quot;aTextureCoord&quot;, 
      type: 'float32', 
      size: 2, 
      glType: PIXI.TYPES.FLOAT, 
      size: 2
  }),
];

// Create a shader function from a shader template!
const shaderFunction = new BatchShaderFactory(
// Vertex Shader
`
attribute vec2 aVertex;
attribute vec2 aTextureCoord;
attribute float aTextureId;

varying float vTextureId;
varying vec2 vTextureCoord;

uniform mat3 projectionMatrix;

void main()
{
    gl_Position = vec4((projectionMatrix * vec3(aVertex.xy, 1)), 0, 1);
    vTextureId = aTextureId;
    vTextureCoord = aTextureCoord;
}
`,

// Fragment Shader
`
uniform uSamplers[%texturesPerBatch%];/* %texturesPerBatch% is a macro and will become a number */\
varying float vTextureId;
varying vec2 vTextureCoord;

void main(void){
    vec4 color;

    /* get color, which is the pixel in texture uSamplers[vTextureId] @ vTextureCoord */
    for (int k = 0; k &lt; %texturesPerBatch%; ++k)
    {
        if (int(vTextureId) == k)
            color = texture2D(uSamplers[k], vTextureCoord);

    }

    gl_FragColor = color;
}
`,
{}).derive();

// Create batch renderer class
const ExampleRenderer = BatchRendererPluginFactory.from({
    attribSet,
    indexProperty: &quot;indices&quot;,
    textureProperty: &quot;texture&quot;,
    texIDAttrib: &quot;aTextureId&quot;, // this will be used to locate the texture in the fragment shader later
    shaderFunction
});

// Remember to do this before instantiating a PIXI.Application or PIXI.Renderer!
PIXI.Renderer.registerPlugin(&quot;ExampleRenderer&quot;, ExampleRenderer);
</code></pre>
<h3>Uniforms Pipeline [Experimental]</h3>
<p>You can take advantage of shader uniforms in batching too! pixi-batch-renderer supports this out of the box
with the <code>AggregateUniformsBatchFactory</code>. There are two modes for uniforms:</p>
<ul>
<li>
<p><strong>Aggregation mode</strong>: Uniforms of each display-object are aggregated into an array. Then an uniform-ID attribute
is uploaded (say <code>aUniformId</code>) that tells the shader which uniform to pick out of an array. The attribute is passed
to the plugin factory via the <code>uniformIDAttrib</code> option.</p>
</li>
<li>
<p><strong>No-aggregation mode</strong>: Uniforms are uploaded in one-element arrays. Display-objects with different uniform values
are not batched together. This is useful if your uniform values don't differ a lot and will avoid another attribute. To
use this mode, simply don't pass an <code>uniformIDAttrib</code>.</p>
</li>
</ul>
<ol>
<li>Aggregation Mode (Example)</li>
</ol>
<pre class="prettyprint source lang-js"><code>const { UniformRedirect, AggregateUniformsBatchFactory } = require('pixi-batch-renderer');

const shaderFunction = new BatchShaderFactory(
// Vertex Shader
`
attribute vec2 aVertex;
attribute vec2 aTextureCoord;
attribute float aTextureId;
attribute float aUniformId;

varying float vTextureId;
varying vec2 vTextureCoord;
varying float vUniformId;

uniform mat3 projectionMatrix;

void main()
{
    gl_Position = vec4((projectionMatrix * vec3(aVertex.xy, 1)), 0, 1);
    vTextureId = aTextureId;
    vTextureCoord = aTextureCoord;

    vUniformId = aUniformId;
}
`,

// Fragment Shader
`
// You can also use this in the vertex shader.
uniform shaderType[%uniformsPerBatch%];
varying float vUniformId;

uniform uSamplers[%texturesPerBatch%];/* %texturesPerBatch% is a macro and will become a number */\
varying float vTextureId;
varying vec2 vTextureCoord;

void main(void){
    vec4 color;
    float type;

    /* get color & shaderType */
    for (int k = 0; k &lt; int(max(%texturesPerBatch%., %uniformsPerBatch%.)); ++k)
    {
        if (int(vTextureId) == k) {
            color = texture2D(uSamplers[k], vTextureCoord);
        }
        if (int(vUniformId) == k) {
            type = shaderType[vUniformId];
        }
    }


    if (type == 1)
    {
        gl_FragColor = color;
    }
    else
    {
        gl_FragColor = vec4(color.rgb * vTextureCoord.x, vTextureCoord.x);
    }
}
`,
{}).derive();

const uniformSet = [
  new UniformRedirect({ source: &quot;type&quot;, uniform: &quot;shadingType&quot; });
];

const ExampleRenderer = BatchRendererPluginFactory.from({
  uniformSet,
  uniformIDAttrib: &quot;aUniformId&quot;,

  // Previous example's stuff
  attribSet,
  indexProperty: &quot;indices&quot;,
  textureProperty: &quot;texture&quot;,
  texIDAttrib: &quot;aTextureId&quot;,
  shaderFunction,

  BatchFactoryClass: AggregateUniformsBatchFactory
})
</code></pre>
<ol start="2">
<li>No Aggregation Mode (Example)</li>
</ol>
<pre class="prettyprint source lang-js"><code>const { UniformRedirect, AggregateUniformsBatchFactory } = require('pixi-batch-renderer');

const shaderFunction = new BatchShaderFactory(
// Vertex Shader (no changes to standard pipeline example!)
`
attribute vec2 aVertex;
attribute vec2 aTextureCoord;
attribute float aTextureId;
varying float vTextureId;
varying vec2 vTextureCoord;

uniform mat3 projectionMatrix;

void main()
{
    gl_Position = vec4((projectionMatrix * vec3(aVertex.xy, 1)), 0, 1);
    vTextureId = aTextureId;
    vTextureCoord = aTextureCoord;
}
`,

// Fragment Shader
`
// Look only one-element instead of %uniformsPerBatch%
uniform shaderType[1];
varying float vUniformId;

uniform uSamplers[%texturesPerBatch%];/* %texturesPerBatch% is a macro and will become a number */\
varying float vTextureId;
varying vec2 vTextureCoord;

void main(void){
    vec4 color;
    float type = shaderType;

    /* get color & shaderType */
    for (int k = 0; k &lt; %texturesPerBatch%; ++k)
    {
        if (int(vTextureId) == k) {
            color = texture2D(uSamplers[k], vTextureCoord);
        }
    }

    if (type == 1)
    {
        gl_FragColor = color;
    }
    else
    {
        gl_FragColor = vec4(color.rgb * vTextureCoord.x, vTextureCoord.x);
    }
}
`,
{}).derive();

const uniformSet = [
  new UniformRedirect({ source: &quot;type&quot;, uniform: &quot;shaderType&quot; });
];

const ExampleRenderer = BatchRendererPluginFactory.from({
  uniformSet,

  attribSet,
  indexProperty: &quot;indices&quot;,
  textureProperty: &quot;texture&quot;,
  texIDAttrib: &quot;aTextureId&quot;,
  shaderFunction,

  BatchFactoryClass: AggregateUniformsBatchFactory
});

PIXI.Renderer.registerPlugin(&quot;erend&quot;, ExampleRenderer);

// Try using with a Sprite!
const sprite = PIXI.Sprite.from(&lt;url>);

sprite.pluginName = &quot;erend&quot;;
sprite.type = 0;// will fade out horizontally in shader
</code></pre>
<h3>Advanced/Customized Batch Generation</h3>
<p>The <code>BatchRendererPluginFactory.from</code> method also accepts these (optional) options that can be used to extend the
behaviour of built-in components:</p>
<ul>
<li>
<p><code>BatchFactoryClass</code>: Child class of <a target="_blank" href="https://pixijs.io/pixi-batch-renderer/PIXI.brend.StdBatchFactory.html">StdBatchFactory</a></p>
</li>
<li>
<p><code>BatchGeometryClass</code>: Child class of <a target="_blank" href="https://pixijs.io/pixi-batch-renderer/PIXI.brend.BatchGeometryFactory.html">BatchGeometry</a></p>
</li>
<li>
<p><code>BatchDrawerClass</code>: Child class of <a target="_blank" href="https://pixijs.io/pixi-batch-renderer/PIXI.brend.BatchDrawer.html">BatchDrawer</a></p>
</li>
<li>
<p><code>BatchRendererClass</code>: If overriding a component does not meet your requirements, you can derive your own batch renderer by
providing a child class of <a target="_blank" href="https://pixijs.io/pixi-batch-renderer/PIXI.brend.BatchRenderer.html">BatchRenderer</a></p>
</li>
</ul></article>
    </section>






        

        <footer class="content-size">
            <div class="footer">
                Documentation generated by <a target="_blank" href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Fri May 22 2020 17:10:12 GMT-0400 (Eastern Daylight Time)
            </div>
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/main.js"></script>


</body>
</html>