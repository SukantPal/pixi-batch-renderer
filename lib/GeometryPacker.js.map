{"version":3,"sources":["../src/GeometryPacker.js"],"names":["CompilerConstants","INDICES_OFFSET","FUNC_SOURCE_BUFFER","packerArguments","GeometryPacker","attributeRedirects","indexProperty","vertexCountProperty","vertexSize","AttributeRedirect","vertexSizeFor","texturePerObject","_targetCompositeAttributeBuffer","_targetCompositeIndexBuffer","_aIndex","_iIndex","_attributeRedirects","_indexProperty","_vertexCountProperty","_vertexSize","_texturePerObject","_aBuffers","_iBuffers","batchVertexCount","batchIndexCount","_getAttributeBuffer","_getIndexBuffer","iIndex","targetObject","textureId","deltaVertices","packerFunction","size","roundedP2","PIXI","utils","nextPow2","Math","ceil","roundedSizeIndex","log2","roundedSize","length","buffer","ViewableBuffer","Uint16Array","_packerFunction","FunctionCompiler","compile","func","packer","packerBody","forEach","redirect","i","_compileSourceBufferExpression","_compileVertexCountExpression","skipReverseTransformation","_sizeOf","j","type","k","console","log","Error","Function","source","sizeOf"],"mappings":"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","sourcesContent":["import AttributeRedirect from './redirects/AttributeRedirect';\nimport * as PIXI from 'pixi.js';\n\nconst CompilerConstants = {\n    INDICES_OFFSET: '__offset_indices_',\n    FUNC_SOURCE_BUFFER: 'getSourceBuffer',\n\n    packerArguments: [\n        'targetObject',\n        'compositeAttributes',\n        'compositeIndices',\n        'aIndex',\n        'iIndex',\n        'textureId',\n    ],\n};\n\n/**\n * Packs the geometry of display-object batches into a\n * composite attribute and index buffer.\n *\n * It works by generating an optimized packer function,\n * which can add objects to the composite geometry. This\n * geometry is interleaved.\n *\n * @memberof PIXI.brend\n */\nexport class GeometryPacker\n{\n    /**\n     * @param attributeRedirects {Array<AttributeRedirect>}\n     * @param indexProperty {string} - property where indicies are\n     *     kept; null/undefined if not required.\n     * @param vertexCountProperty {string | number} - property where\n     *      no. of vertices for each object are kept. This could also\n     *      be a constant.\n     * @param vertexSize {number} - vertex size, calculated by\n     *     default. This should exclude the vertex attribute.\n     */\n    constructor(attributeRedirects, indexProperty, vertexCountProperty,\n        vertexSize = AttributeRedirect.vertexSizeFor(attributeRedirects),\n        texturePerObject)\n    {\n        vertexSize += texturePerObject * 4;// texture indices are also passed\n\n        /** @private */\n        this._targetCompositeAttributeBuffer = null;\n        /** @private */\n        this._targetCompositeIndexBuffer = null;\n        /** @private */\n        this._aIndex = 0;\n        /** @private */\n        this._iIndex = 0;\n\n        /** @private */\n        this._attributeRedirects = attributeRedirects;\n        /** @private */\n        this._indexProperty = indexProperty;\n        /** @private */\n        this._vertexCountProperty = vertexCountProperty;\n        /** @private */\n        this._vertexSize = vertexSize;\n        /** @private */\n        this._texturePerObject = texturePerObject;\n\n        /** @private */\n        this._aBuffers = [];// @see _getAttributeBuffer\n        /** @private */\n        this._iBuffers = [];// @see _getIndexBuffer\n    }\n\n    /**\n     * A generated function that will append an object's\n     * attributes and indices to composite buffers.\n     *\n     * The composite attribute buffer is interleaved.\n     *\n     * The composite index buffer has adjusted indices. It\n     * accounts for the new positions of vertices in the\n     * composite attribute buffer.\n     *\n     * You can overwrite this property with a custom packer\n     * function.\n     */\n    get packerFunction()\n    {\n        if (!this._packerFunction)\n        {\n            this._packerFunction\n                = new GeometryPacker.FunctionCompiler(this).compile();\n        }\n\n        return this._packerFunction;\n    }\n\n    set packerFunction(func)// eslint-disable-line require-jsdoc\n    {\n        this._packerFunction = func;\n    }\n\n    /**\n     * This is the currently active composite attribute\n     * buffer. It may contain garbage in unused locations.\n     *\n     * @member {PIXI.ViewableBuffer}\n     */\n    get compositeAttributes()\n    {\n        return this._targetCompositeAttributeBuffer;\n    }\n\n    /**\n     * This is the currently active composite index\n     * buffer. It may contain garbage in unused locations.\n     *\n     * It will be `null` if `indexProperty` was not given.\n     */\n    get compositeIndices()\n    {\n        return this._targetCompositeIndexBuffer;\n    }\n\n    reset(batchVertexCount, batchIndexCount)\n    {\n        this._targetCompositeAttributeBuffer\n            = this._getAttributeBuffer(batchVertexCount);\n\n        if (this.indexProperty)\n        {\n            this._targetCompositeIndexBuffer\n                = this._getIndexBuffer(batchIndexCount);\n        }\n\n        this._aIndex = this.iIndex = 0;\n    }\n\n    pack(targetObject, textureId)\n    {\n        const deltaVertices = this.packerFunction(\n            targetObject,\n            this._targetCompositeAttributeBuffer,\n            this._targetCompositeIndexBuffer,\n            this._aIndex,\n            this._iIndex,\n            textureId\n        );\n\n        this._aIndex += deltaVertices * this._vertexSize;\n        this._iIndex += deltaVertices;\n    }\n\n    /** @private */\n    _getAttributeBuffer(size)\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSize];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer\n                = new PIXI.ViewableBuffer(roundedSize * this._vertexSize);\n        }\n\n        return buffer;\n    }\n\n    /** @private */\n    _getIndexBuffer(size)\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer\n                = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * @function\n     * @name PackerFunction\n     * @memberof PIXI.brend\n     *\n     * This function type is used by `GeometryPacker#packerFunction`.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object to pack\n     * @param compositeAttributes {PIXI.ViewableBuffer}\n     * @param compositeIndices {Uint16Array}\n     * @param aIndex {number} - Offset in the composite attribute buffer\n     *      in bytes at which the object's geometry should be inserted.\n     * @param iIndex {number} - Number of vertices already packed in the\n     *      composite index buffer.\n     * @return No. of vertices added\n     * @see PIXI.brend.GeometryPacker#packerFunction\n     */\n\n    /** @private */\n    static FunctionCompiler = class\n    {\n        constructor(packer)\n        {\n            this.packer = packer;\n        }\n\n        compile()\n        {\n            const packer = this.packer;\n\n            let packerBody = ``;\n\n            /* Source offset variables for attribute buffers &\n                the corresponding buffer-view references. */\n            packer._attributeRedirects.forEach((redirect, i) =>\n            {\n                packerBody += `\n                    let __offset_${i} = 0;\n                    const __buffer_${i} = (\n                        ${this._compileSourceBufferExpression(redirect, i)});\n                `;\n            });\n\n            /* Basis for the \"packing\" for-loop. */\n            packerBody += `\n                const {\n                    int8View,\n                    uint8View,\n                    int16View,\n                    uint16View,\n                    int32View,\n                    uint32View,\n                    float32View,\n                } = compositeAttributes;\n\n                const vertexCount = ${this._compileVertexCountExpression()};\n\n                let adjustedAIndex = 0;\n\n                for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n                {\n            `;\n\n            // Eliminate offset conversion when adjacent attributes\n            // have similar source-types.\n            let skipReverseTransformation = false;\n\n            /* Packing for-loop body. */\n            for (let i = 0; i < packer._attributeRedirects.length; i++)\n            {\n                const redirect = packer._attributeRedirects[i];\n\n                /* Initialize adjsutedAIndex in terms of source type. */\n                if (!skipReverseTransformation)\n                {\n                    packerBody += `\n                        adjustedAIndex = aIndex / ${this._sizeOf(i)};\n                    `;\n                }\n\n                if (typeof redirect.size === 'number')\n                {\n                    for (let j = 0; j < redirect.size; j++)\n                    {\n                        packerBody += `\n                            ${redirect.type}View[adjustedAIndex++] =\n                                __buffer_${i}[__offset_${i}++];\n                        `;\n                    }\n                }\n                else\n                {\n                    packerBody += `\n                            ${redirect.type}View[adjustedAIndex++] =\n                                __buffer_${i};\n                    `;\n                }\n\n                if (packer._attributeRedirects[i + 1]\n                    && (this._sizeOf(i + 1) !== this._sizeOf(i)))\n                {\n                    packerBody += `\n                        aIndex = adjustedAIndex * ${this._sizeOf(i)};\n                    `;\n                }\n                else\n                {\n                    skipReverseTransformation = true;\n                }\n            }\n\n            if (skipReverseTransformation)\n            {\n                if (this._sizeOf(packer._attributeRedirects.length - 1)\n                        !== 4)\n                {\n                    packerBody += `\n                        aIndex = adjustedAIndex * ${this._sizeOf(\n                        packer._attributeRedirects.length - 1)}\n                    `;\n                    skipReverseTransformation = false;\n                }\n            }\n\n            if (packer._texturePerObject > 0)\n            {\n                if (packer._texturePerObject > 1)\n                {\n                    if (!skipReverseTransformation)\n                    {\n                        packerBody += `\n                            adjustedAIndex = aIndex / 4;\n                        `;\n                    }\n\n                    for (let k = 0; k < packer._texturePerObject; k++)\n                    {\n                        packerBody += `\n                            float32View[adjustedAIndex++] = textureId[${k}];\n                        `;\n                    }\n\n                    packerBody += `\n                        aIndex = adjustedAIndex * 4;\n                    `;\n                }\n                else if (!skipReverseTransformation)\n                {\n                    packerBody += `\n                        float32View[aIndex] = textureId;\n                        aIndex += 4;\n                    `;\n                }\n                else\n                {\n                    packerBody += `\n                        float32View[adjustedAIndex++] = textureId;\n                        aIndex = adjustedAIndex * 4;\n                    `;\n                }\n            }\n\n            /* Close the packing for-loop. */\n            packerBody += '}';\n\n            if (this.packer._indexProperty)\n            {\n                packerBody += `\n                    const initialIndicesCount = iIndex;\n                    const indexCount\n                        = targetObject[${this.packer._indexProperty}].length;\n\n                    for (let j = 0; j < indexCount; j++)\n                    {\n                        compositeIndices[iIndex++] = initialIndicesCount +\n                            targetObject[${this.packer._indexProperty}][j];\n                    }\n                `;\n            }\n\n            console.log(packerBody);\n            throw new Error('error compiler');\n\n            // eslint-disable-next-line no-new-func\n            return new Function(\n                ...CompilerConstants.packerArguments,\n                packerBody);\n        }\n\n        _compileSourceBufferExpression(redirect, i)\n        {\n            return (typeof redirect.source === 'string')\n                ? `targetObject[${redirect.source}]`\n                : `attributeRedirects[${i}].source(targetObject)`;\n        }\n\n        _compileVertexCountExpression()\n        {\n            if (!this.packer._vertexCountProperty)\n            {\n                // auto-calculate based on primary attribute\n                return `__buffer_0.length / __size_0`;\n            }\n\n            return (\n                (typeof this.packer._vertexCountProperty === 'string')\n                    ? `targetObject.${this.packer._vertexCountProperty}`\n                    : `${this.packer._vertexCountProperty}`\n            );\n        }\n\n        _sizeOf(i)\n        {\n            return PIXI.ViewableBuffer.sizeOf(\n                this.packer._attributeRedirects[i].type);\n        }\n    }\n}\n\nexport default GeometryPacker;\n"],"file":"GeometryPacker.js"}