{"version":3,"sources":["../src/GeometryPacker.js"],"names":["CompilerConstants","INDICES_OFFSET","FUNC_SOURCE_BUFFER","packerArguments","GeometryPacker","attributeRedirects","indexProperty","vertexCountProperty","vertexSize","AttributeRedirect","vertexSizeFor","texturePerObject","_targetCompositeAttributeBuffer","_targetCompositeIndexBuffer","_aIndex","_iIndex","_attributeRedirects","_indexProperty","_vertexCountProperty","_vertexSize","_texturePerObject","_aBuffers","_iBuffers","batchVertexCount","batchIndexCount","_getAttributeBuffer","_getIndexBuffer","iIndex","targetObject","textureId","packerFunction","size","roundedP2","PIXI","utils","nextPow2","Math","ceil","roundedSizeIndex","log2","roundedSize","length","buffer","ViewableBuffer","Uint16Array","_packerFunction","FunctionCompiler","compile","func","packer","packerBody","forEach","redirect","i","_compileSourceBufferExpression","_compileVertexCountExpression","skipReverseTransformation","_sizeOf","j","type","k","Function","source","sizeOf"],"mappings":"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","sourcesContent":["import AttributeRedirect from './redirects/AttributeRedirect';\nimport * as PIXI from 'pixi.js';\n\nconst CompilerConstants = {\n    INDICES_OFFSET: '__offset_indices_',\n    FUNC_SOURCE_BUFFER: 'getSourceBuffer',\n\n    packerArguments: [\n        'targetObject',\n        'compositeAttributes',\n        'compositeIndices',\n        'aIndex',\n        'iIndex',\n        'textureId',\n        'attributeRedirects',\n    ],\n};\n\n/**\n * Packs the geometry of display-object batches into a\n * composite attribute and index buffer.\n *\n * It works by generating an optimized packer function,\n * which can add objects to the composite geometry. This\n * geometry is interleaved and is in accordance with\n * what {@link PIXI.brend.BatchRenderer.generateCompositeGeometry}\n * would return.\n *\n * @memberof PIXI.brend\n */\nclass GeometryPacker\n{\n    /**\n     * @param {PIXI.brend.AttributeRedirect[]} attributeRedirects\n     * @param {string} indexProperty - property where indicies are\n     *     kept; null/undefined if not required.\n     * @param {string | number} vertexCountProperty - property where\n     *      no. of vertices for each object are kept. This could also\n     *      be a constant.\n     * @param {number} vertexSize - vertex size, calculated by\n     *     default. This should exclude the vertex attribute\n     * @param {number} texturePerObject - no. of textures per object\n     */\n    constructor(attributeRedirects, indexProperty, vertexCountProperty,\n        vertexSize = AttributeRedirect.vertexSizeFor(attributeRedirects),\n        texturePerObject)\n    {\n        vertexSize += texturePerObject * 4;// texture indices are also passed\n        /** @private */\n        this._targetCompositeAttributeBuffer = null;\n        /** @private */\n        this._targetCompositeIndexBuffer = null;\n        /** @private */\n        this._aIndex = 0;\n        /** @private */\n        this._iIndex = 0;\n\n        /** @private */\n        this._attributeRedirects = attributeRedirects;\n        /** @private */\n        this._indexProperty = indexProperty;\n        /** @private */\n        this._vertexCountProperty = vertexCountProperty;\n        /** @private */\n        this._vertexSize = vertexSize;\n        /** @private */\n        this._texturePerObject = texturePerObject;\n\n        /** @private */\n        this._aBuffers = [];// @see _getAttributeBuffer\n        /** @private */\n        this._iBuffers = [];// @see _getIndexBuffer\n    }\n\n    /**\n     * A generated function that will append an object's\n     * attributes and indices to composite buffers.\n     *\n     * The composite attribute buffer is interleaved.\n     *\n     * The composite index buffer has adjusted indices. It\n     * accounts for the new positions of vertices in the\n     * composite attribute buffer.\n     *\n     * You can overwrite this property with a custom packer\n     * function.\n     *\n     * @member {PIXI.brend.PackerFunction}\n     */\n    get packerFunction()\n    {\n        if (!this._packerFunction)\n        {\n            this._packerFunction\n                = new FunctionCompiler(this).compile();// eslint-disable-line\n        }\n\n        return this._packerFunction;\n    }\n\n    set packerFunction(func)// eslint-disable-line require-jsdoc\n    {\n        this._packerFunction = func;\n    }\n\n    /**\n     * This is the currently active composite attribute\n     * buffer. It may contain garbage in unused locations.\n     *\n     * @member {PIXI.ViewableBuffer}\n     */\n    get compositeAttributes()\n    {\n        return this._targetCompositeAttributeBuffer;\n    }\n\n    /**\n     * This is the currently active composite index\n     * buffer. It may contain garbage in unused locations.\n     *\n     * It will be `null` if `indexProperty` was not given.\n     *\n     * @member {Uint16Array}\n     */\n    get compositeIndices()\n    {\n        return this._targetCompositeIndexBuffer;\n    }\n\n    /**\n     * @param {number} batchVertexCount\n     * @param {number} batchIndexCount\n     */\n    reset(batchVertexCount, batchIndexCount)\n    {\n        this._targetCompositeAttributeBuffer\n            = this._getAttributeBuffer(batchVertexCount);\n\n        if (this._indexProperty)\n        {\n            this._targetCompositeIndexBuffer\n                = this._getIndexBuffer(batchIndexCount);\n        }\n\n        this._aIndex = this.iIndex = 0;\n    }\n\n    /**\n     * @param {PIXI.DisplayObject} targetObject\n     * @param {number} textureId\n     */\n    pack(targetObject, textureId)\n    {\n        this.packerFunction(\n            targetObject,\n            this._targetCompositeAttributeBuffer,\n            this._targetCompositeIndexBuffer,\n            this._aIndex,\n            this._iIndex,\n            textureId,\n            this._attributeRedirects\n        );\n    }\n\n    /** @private */\n    _getAttributeBuffer(size)\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._aBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer\n                = new PIXI.ViewableBuffer(roundedSize * this._vertexSize);\n        }\n\n        return buffer;\n    }\n\n    /** @private */\n    _getIndexBuffer(size)\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer\n                = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n}\n\n// FunctionCompiler was intented to be a static inner\n// class in GeometryPacker. However, due to a bug in\n// JSDoc (3.6.3), I've put it down here :)\n//\n// https://github.com/jsdoc/jsdoc/issues/1673\n\n/** @private */\nconst FunctionCompiler = class\n{\n    /**\n     * @param {PIXI.brend.GeometryPacker} packer\n     */\n    constructor(packer)\n    {\n        this.packer = packer;\n    }\n\n    compile()\n    {\n        const packer = this.packer;\n\n        let packerBody = ``;\n\n        /* Source offset variables for attribute buffers &\n            the corresponding buffer-view references. */\n        packer._attributeRedirects.forEach((redirect, i) =>\n        {\n            packerBody += `\n                let __offset_${i} = 0;\n                const __buffer_${i} = (\n                    ${this._compileSourceBufferExpression(redirect, i)});\n            `;\n        });\n\n        /* Basis for the \"packing\" for-loop. */\n        packerBody += `\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;\n\n        // Eliminate offset conversion when adjacent attributes\n        // have similar source-types.\n        let skipReverseTransformation = false;\n\n        /* Packing for-loop body. */\n        for (let i = 0; i < packer._attributeRedirects.length; i++)\n        {\n            const redirect = packer._attributeRedirects[i];\n\n            /* Initialize adjsutedAIndex in terms of source type. */\n            if (!skipReverseTransformation)\n            {\n                packerBody += `\n                    adjustedAIndex = aIndex / ${this._sizeOf(i)};\n                `;\n            }\n\n            if (typeof redirect.size === 'number')\n            {\n                for (let j = 0; j < redirect.size; j++)\n                {\n                    packerBody += `\n                        ${redirect.type}View[adjustedAIndex++] =\n                            __buffer_${i}[__offset_${i}++];\n                    `;\n                }\n            }\n            else\n            {\n                packerBody += `\n                        ${redirect.type}View[adjustedAIndex++] =\n                            __buffer_${i};\n                `;\n            }\n\n            if (packer._attributeRedirects[i + 1]\n                && (this._sizeOf(i + 1) !== this._sizeOf(i)))\n            {\n                packerBody += `\n                    aIndex = adjustedAIndex * ${this._sizeOf(i)};\n                `;\n            }\n            else\n            {\n                skipReverseTransformation = true;\n            }\n        }\n\n        if (skipReverseTransformation)\n        {\n            if (this._sizeOf(packer._attributeRedirects.length - 1)\n                    !== 4)\n            {\n                packerBody += `\n                    aIndex = adjustedAIndex * ${this._sizeOf(\n        packer._attributeRedirects.length - 1)}\n                `;\n                skipReverseTransformation = false;\n            }\n        }\n\n        if (packer._texturePerObject > 0)\n        {\n            if (packer._texturePerObject > 1)\n            {\n                if (!skipReverseTransformation)\n                {\n                    packerBody += `\n                        adjustedAIndex = aIndex / 4;\n                    `;\n                }\n\n                for (let k = 0; k < packer._texturePerObject; k++)\n                {\n                    packerBody += `\n                        float32View[adjustedAIndex++] = textureId[${k}];\n                    `;\n                }\n\n                packerBody += `\n                    aIndex = adjustedAIndex * 4;\n                `;\n            }\n            else if (!skipReverseTransformation)\n            {\n                packerBody += `\n                    float32View[aIndex] = textureId;\n                    aIndex += 4;\n                `;\n            }\n            else\n            {\n                packerBody += `\n                    float32View[adjustedAIndex++] = textureId;\n                    aIndex = adjustedAIndex * 4;\n                `;\n            }\n        }\n\n        /* Close the packing for-loop. */\n        packerBody += `}\n            ${this.packer._indexProperty\n        ? `const oldAIndex = this._aIndex;`\n        : ''}\n            this._aIndex = aIndex;\n        `;\n\n        if (this.packer._indexProperty)\n        {\n            packerBody += `\n                const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n                const indexCount\n                    = targetObject['${this.packer._indexProperty}'].length;\n\n                for (let j = 0; j < indexCount; j++)\n                {\n                    compositeIndices[iIndex++] = verticesBefore +\n                        targetObject['${this.packer._indexProperty}'][j];\n                }\n\n                this._iIndex = iIndex;\n            `;\n        }\n\n        // eslint-disable-next-line no-new-func\n        return new Function(\n            ...CompilerConstants.packerArguments,\n            packerBody);\n    }\n\n    _compileSourceBufferExpression(redirect, i)\n    {\n        return (typeof redirect.source === 'string')\n            ? `targetObject['${redirect.source}']`\n            : `attributeRedirects[${i}].source(targetObject)`;\n    }\n\n    _compileVertexCountExpression()\n    {\n        if (!this.packer._vertexCountProperty)\n        {\n            // auto-calculate based on primary attribute\n            return `__buffer_0.length / ${\n                this.packer._attributeRedirects[0].size}`;\n        }\n\n        return (\n            (typeof this.packer._vertexCountProperty === 'string')\n                ? `targetObject.${this.packer._vertexCountProperty}`\n                : `${this.packer._vertexCountProperty}`\n        );\n    }\n\n    _sizeOf(i)\n    {\n        return PIXI.ViewableBuffer.sizeOf(\n            this.packer._attributeRedirects[i].type);\n    }\n};\n\n/**\n * @typedef { Function } PackerFunction\n * @memberof PIXI.brend\n *\n * This function type is used by `GeometryPacker#packerFunction`.\n *\n * It should add to this._aIndex and this._iIndex the number\n * of vertices and indices appended.\n *\n * @param targetObject {PIXI.DisplayObject} - object to pack\n * @param compositeAttributes {PIXI.ViewableBuffer}\n * @param compositeIndices {Uint16Array}\n * @param aIndex {number} - Offset in the composite attribute buffer\n *      in bytes at which the object's geometry should be inserted.\n * @param iIndex {number} - Number of vertices already packed in the\n *      composite index buffer.\n * @see PIXI.brend.GeometryPacker#packerFunction\n */\n\nexport { GeometryPacker };\n\nexport default GeometryPacker;\n"],"file":"GeometryPacker.js"}