{"version":3,"file":"pixi-batch-renderer.mjs","sources":["../src/redirects/Redirect.ts","../src/redirects/AttributeRedirect.ts","../src/redirects/UniformRedirect.ts","../src/StdBatch.ts","../src/StdBatchFactory.ts","../src/BatchGeometryFactory.ts","../src/resolve/resolveConstantOrProperty.ts","../src/resolve/resolveFunctionOrProperty.ts","../src/BatchDrawer.ts","../src/BatchRenderer.ts","../src/BatchRendererPluginFactory.ts","../src/BatchShaderFactory.ts","../src/AggregateUniformsBatch.ts","../src/AggregateUniformsBatchFactory.ts","../src/index.ts"],"sourcesContent":["import * as PIXI from 'pixi.js';\n\n/**\n * Redirects are used to aggregate the resources needed by the WebGL pipeline to render\n * a display-object. This includes the base primitives (geometry), uniforms, and\n * textures (which are handled as \"special\" uniforms).\n *\n * @memberof PIXI.brend\n * @class\n * @abstract\n * @see PIXI.brend.AttributeRedirect\n */\nexport abstract class Redirect\n{\n    public source: string | ((displayObject: PIXI.DisplayObject) => any);\n    public glslIdentifer: string;\n\n    constructor(source: string | ((displayObject: PIXI.DisplayObject) => any), glslIdentifer: string)\n    {\n        /**\n         * The property on the display-object that holds the resource.\n         *\n         * Instead of a property, you can provide a callback that generates the resource\n         * on invokation.\n         *\n         * @member {string | Function}\n         */\n        this.source = source;\n\n        /**\n         * The shader variable that references the resource, e.g. attribute or uniform\n         * name.\n         * @member {string}\n         */\n        this.glslIdentifer = glslIdentifer;\n    }\n}\n\nexport default Redirect;\n","import * as PIXI from 'pixi.js';\nimport { Redirect } from './Redirect';\n\ninterface IAttributeRedirectOptions\n{\n    source: string | ((db: PIXI.DisplayObject) => any);\n    attrib: string;\n    type: string;\n    size?: number | '%notarray%';\n    glType: number;\n    glSize: number;\n    normalize?: boolean;\n}\n\n/**\n * This redirect defines an attribute of a display-object's geometry. The attribute\n * data is expected to be stored in a `PIXI.ViewableBuffer`, in an array, or (if\n * just one element) as the property itself.\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.brend.Redirect\n * @example\n * // This attribute redirect calculates the tint used on top of a texture. Since the\n * // tintMode can change anytime, it is better to use a derived source (function).\n * //\n * // Furthermore, the color is uploaded as four bytes (`attribute vec4 aTint`) while the\n * // source returns an integer. This is done by splitting the 32-bit integer into four\n * // 8-bit bytes.\n * new PIXI.brend.AttributeRedirect({\n *     source: (tgt: ExampleDisplay) => (tgt.alpha < 1.0 && tgt.tintMode === PREMULTIPLY)\n *          ? premultiplyTint(tgt.rgb, tgt.alpha)\n *          : tgt.rgb + (tgt.alpha << 24);\n *     attrib: 'aTint',\n *     type: 'int32',\n *     size: '%notarray%', // optional/default\n *     glType: PIXI.TYPES.UNSIGNED_BYTE,\n *     glSize: 4,\n *     normalize: true // We are using [0, 255] range for RGBA here. Must normalize to [0, 1].\n * });\n */\nexport class AttributeRedirect extends Redirect\n{\n    public type: string;\n    public size: number | '%notarray%';\n    public glType: PIXI.TYPES;\n    public glSize: number;\n    public normalize: boolean;\n\n    public properSize: number;\n\n    /**\n     * @param {object} options\n     * @param {string | Function} options.source - redirect source\n     * @param {string} options.attrib - shader attribute variable\n     * @param {string}[options.type='float32'] - the type of data stored in the source\n     * @param {number | '%notarray%'}[options.size=0] - size of the source array ('%notarray' if not an array & just one element)\n     * @param {PIXI.TYPES}[options.glType=PIXI.TYPES.FLOAT] - data format to be uploaded in\n     * @param {number} options.glSize - number of elements to be uploaded as (size of source and upload must match)\n     * @param {boolean}[options.normalize=false] - whether to normalize the data before uploading\n     */\n    constructor(options: IAttributeRedirectOptions)\n    {\n        super(options.source, options.attrib);\n\n        /**\n         * The type of data stored in the source buffer. This can be any of: `int8`, `uint8`,\n         * `int16`, `uint16`, `int32`, `uint32`, or (by default) `float32`.\n         *\n         * @member {string}\n         * @see [PIXI.ViewableBuffer#view]{@link https://pixijs.download/dev/docs/PIXI.ViewableBuffer.html}\n         * @default 'float32'\n         */\n        this.type = options.type;\n\n        /**\n         * Number of elements to extract out of `source` with\n         * the given view type, for one vertex.\n         *\n         * If source isn't an array (only one element), then\n         * you can set this to `'%notarray%'`.\n         *\n         * @member {number | '%notarray%'}\n         */\n        this.size = options.size;\n\n        /**\n         * This is equal to `size` or 1 if size is `%notarray%`.\n         *\n         * @member {number}\n         */\n        this.properSize = (options.size === '%notarray%' || options.size === undefined) ? 1 : options.size;\n\n        /**\n         * Type of attribute, when uploading.\n         *\n         * Normally, you would use the corresponding type for\n         * the view on source. However, to speed up uploads\n         * you can aggregate attribute values in larger data\n         * types. For example, an RGBA vec4 (byte-sized channels)\n         * can be represented as one `Uint32`, while having\n         * a `glType` of `UNSIGNED_BYTE`.\n         *\n         * @member {PIXI.TYPES}\n         */\n        this.glType = options.glType;\n\n        /**\n         * Size of attribute in terms of `glType`.\n         *\n         * Note that `glSize * glType <= size * type`\n         *\n         * @readonly\n         */\n        this.glSize = options.glSize;\n\n        /**\n         * Whether to normalize the attribute values.\n         *\n         * @member {boolean}\n         * @readonly\n         */\n        this.normalize = !!options.normalize;\n    }\n\n    static vertexSizeFor(attributeRedirects: Array<AttributeRedirect>): number\n    {\n        return attributeRedirects.reduce(\n            (acc, redirect) =>\n                (PIXI.ViewableBuffer.sizeOf(redirect.type)\n                    * redirect.properSize)\n                + acc,\n            0);\n    }\n}\n","import * as PIXI from 'pixi.js';\nimport { Redirect } from './Redirect';\n\ninterface IUniformRedirectOptions\n{\n    source: string | ((displayObject: PIXI.DisplayObject) => any);\n    uniform: string;\n}\n\n/**\n * This redirect is used to aggregate & upload uniforms required for shading the\n * display-object.\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.brend.Redirect\n * @example\n * // The data-type of this uniform is defined in your shader.\n * new PIXI.brend.UniformRedirect({\n *      source: (dob: PIXI.DisplayObject) => dob.transform.worldTransform,\n *      uniform: \"transform\"\n * });\n */\nexport class UniformRedirect extends Redirect\n{\n    constructor(options: IUniformRedirectOptions)\n    {\n        super(options.source, options.uniform);\n    }\n}\n","import * as PIXI from 'pixi.js';\n\n/**\n * Resources that need to be uploaded to WebGL to render one batch.\n *\n * To customize batches, you must create your own batch factory by extending the\n * `PIXI.brend.StdBatchFactory` class.\n *\n * @memberof PIXI.brend\n * @class\n * @see PIXI.brend.StdBatchFactory\n */\nexport class StdBatch\n{\n    geometryOffset: number;\n    uidMap: any;\n    state: PIXI.State;\n\n    batchBuffer: Array<PIXI.DisplayObject>;\n    textureBuffer: Array<PIXI.BaseTexture>;\n\n    constructor(geometryOffset?: number)\n    {\n        /**\n         * Index of the first vertex of this batch's geometry in the uploaded geometry.\n         *\n         * @member {number}\n         */\n        this.geometryOffset = geometryOffset;\n\n        /**\n         * Textures that are used by the display-object's in this batch.\n         *\n         * @member {Array<PIXI.Texture>}\n         */\n        this.textureBuffer = null;\n\n        /**\n         * Map of base-texture UIDs to texture indices into `uSamplers`.\n         *\n         * @member {Map<number, number>}\n         */\n        this.uidMap = null;\n\n        /**\n         * State required to render this batch.\n         *\n         * @member {PIXI.State}\n         */\n        this.state = null;\n    }\n\n    /**\n     * Uploads the resources required before rendering this batch. If you override\n     * this, you must call `super.upload`.\n     *\n     * @param {PIXI.Renderer} renderer\n     */\n    upload(renderer: PIXI.Renderer): void\n    {\n        this.textureBuffer.forEach((tex, i) =>\n        {\n            renderer.texture.bind(tex, i);\n        });\n\n        renderer.state.set(this.state);\n    }\n\n    /**\n     * Reset this batch to become \"fresh\"!\n     */\n    reset(): void\n    {\n        this.textureBuffer = this.uidMap = this.state = null;\n\n        if (this.batchBuffer)\n        {\n            this.batchBuffer.length = 0;\n        }\n    }\n}\n","import { StdBatch } from './StdBatch';\nimport BatchRenderer from './BatchRenderer';\n\n/**\n * Factory for producing \"standard\" (based on state, geometry, & textures) batches of\n * display-objects.\n *\n * **NOTE:** Instead of \"building\" batches, this factory actually keeps the batches in\n * a buffer so they can be accessed together at the end.\n *\n * **Shared Textures**: If display-objects in the same batch use the same base-texture,\n * then that base-texture is not uploaded twice. This allows for more better batch density\n * when you use texture atlases (textures with same base-texture). This is one reason why\n * textures are treated as \"special\" uniforms.\n *\n * @memberof PIXI.brend\n * @class\n * @see PIXI.brend.AggregateUniformsBatchFactory\n */\nexport class StdBatchFactory\n{\n    protected _renderer: BatchRenderer;\n\n    protected _textureCount: number;\n    protected _textureLimit: number;\n    protected _textureProperty: string;\n\n    /** @internal */\n    public _batchBuffer: Array<PIXI.DisplayObject>;\n    protected _state: PIXI.State;\n\n    protected _textureBuffer: any;\n    protected _textureBufferLength: number;\n    protected _textureIndexedBuffer: Array<PIXI.BaseTexture>;\n    protected _textureIndexMap: any;\n\n    protected _batchPool: any[];\n    protected _batchCount: number;\n\n    // _putTexture is optimized for the one texture/display-object case.\n    protected _putTexture: any;\n\n    /**\n     * @param {PIXI.brend.BatchRenderer} renderer\n     */\n    constructor(renderer: BatchRenderer)\n    {\n        /**\n         * @member {PIXI.brend.BatchRenderer}\n         * @protected\n         */\n        this._renderer = renderer;\n        this._state = null;\n\n        /**\n         * Textures per display-object\n         * @member {number}\n         */\n        this._textureCount = renderer._texturesPerObject;\n\n        /**\n         * Property in which textures are kept of display-objects\n         * @member {string}\n         */\n        this._textureProperty = renderer._textureProperty;\n\n        /**\n         * Max. no of textures per batch (should be <= texture units of GPU)\n         * @member {number}\n         */\n        this._textureLimit = renderer.MAX_TEXTURES;\n\n        /**\n         * @member {object}\n         */\n        this._textureBuffer = {}; // uid : texture map\n        this._textureBufferLength = 0;\n        this._textureIndexedBuffer = []; // array of textures\n        this._textureIndexMap = {}; // uid : index in above\n\n        /**\n         * Display-objects in current batch\n         * @protected\n         */\n        this._batchBuffer = [];\n\n        /**\n         * Pool to batch objects into which data is fed.\n         * @member {any[]}\n         * @protected\n         */\n        this._batchPool = [];\n\n        /**\n         * Number of batches created since last reset.\n         * @member {number}\n         * @protected\n         */\n        this._batchCount = 0;\n\n        if (this._textureCount === 1)\n        {\n            this._putTexture = this._putSingleTexture;\n        }\n        else\n        {\n            this._putTexture = this._putAllTextures;\n        }\n    }\n\n    /**\n     * Puts the display-object into the current batch, if possible.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object to add\n     * @param state {PIXI.State} - state required by that object\n     * @return {boolean} whether the object was added to the batch. If it wasn't, you should \"build\" it.\n     */\n    put(targetObject: PIXI.DisplayObject, state: PIXI.State): boolean\n    {\n        // State compat\n        if (!this._state)\n        {\n            this._state = state;\n        }\n        else if (this._state.data !== state.data)\n        {\n            return false;\n        }\n\n        // Customized compat\n        if (!this._put(targetObject))\n        {\n            return false;\n        }\n\n        // Texture compat\n        if (this._textureCount > 0 && !this._putTexture((targetObject as any)[this._textureProperty]))\n        {\n            return false;\n        }\n\n        this._batchBuffer.push(targetObject);\n\n        return true;\n    }\n\n    /**\n     * Creates the batch object and pushes it into the pool This also resets any state\n     * so that a new batch can be started again.\n     *\n     * @param batch {PIXI.brend.Batch}\n     */\n    build(geometryOffset: number): void\n    {\n        const batch = this._nextBatch() as StdBatch;\n\n        batch.geometryOffset = geometryOffset;\n        this._buildBatch(batch);\n\n        this._state = null;\n        this._batchBuffer = [];\n        this._textureBuffer = {};\n        this._textureIndexMap = {};\n        this._textureBufferLength = 0;\n        this._textureIndexedBuffer = [];\n    }\n\n    /**\n     * @returns {boolean} - whether this factory is ready to start a new batch from\n     *  \"start\". If not, then the current batch must be built before starting a new one.\n     */\n    ready(): boolean\n    {\n        return this._batchBuffer.length === 0;\n    }\n\n    /**\n     * Clears the batch pool.\n     */\n    reset(): void\n    {\n        this._batchCount = 0;\n    }\n\n    /**\n     * Returns the built batch pool. The array returned may be larger than the pool\n     * itself.\n     *\n     * @returns {Array<object>}\n     */\n    access(): any[]\n    {\n        return this._batchPool;\n    }\n\n    /**\n     * Size of the batch pool built since last reset.\n     */\n    size(): number\n    {\n        return this._batchCount;\n    }\n\n    /**\n     * Should store any information from the display-object to be put into\n     * the batch.\n     * @param {PIXI.DisplayObject} displayObject\n     * @returns {boolean} - whether the display-object was \"compatible\" with\n     *      other display-objects in the batch. If not, it should not have been\n     *      added.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected _put(displayObject: PIXI.DisplayObject): boolean\n    {\n        // Override this\n        return true;\n    }\n\n    /**\n     * @returns {object} a new batch\n     * @protected\n     * @example\n     * _newBatch(): CustomBatch\n     * {\n     *      return new CustomBatch();\n     * }\n     */\n    protected _newBatch(): any\n    {\n        return new StdBatch();\n    }\n\n    /**\n     * @param {number} geometryOffset\n     */\n    protected _nextBatch(geometryOffset?: number): any\n    {\n        if (this._batchCount === this._batchPool.length)\n        {\n            this._batchPool.push(this._newBatch());\n        }\n\n        const batch = this._batchPool[this._batchCount++];\n\n        batch.reset();\n        batch.geometryOffset = geometryOffset;\n\n        return batch;\n    }\n\n    /**\n     * Should add any information required to render the batch. If you override this,\n     * you must call `super._buildBatch` and clear any state.\n     * @param {object} batch\n     * @protected\n     * @example\n     * _buildBatch(batch: any): void\n     * {\n     *      super._buildBatch(batch);\n     *      batch.depth = this.generateDepth();\n     *\n     *      // if applicable\n     *      this.resetDepthGenerator();\n     * }\n     */\n    protected _buildBatch(batch: any): void\n    {\n        batch.batchBuffer = this._batchBuffer;\n        batch.textureBuffer = this._textureIndexedBuffer;\n        batch.uidMap = this._textureIndexMap;\n        batch.state = this._state;\n    }\n\n    // Optimized _putTexture case.\n    private _putSingleTexture(texture: PIXI.BaseTexture | PIXI.Texture): boolean\n    {\n        if ('baseTexture' in texture)\n        {\n            texture = texture.baseTexture;\n        }\n\n        const baseTexture: PIXI.BaseTexture = texture as PIXI.BaseTexture;\n\n        if (this._textureBuffer[baseTexture.uid])\n        {\n            return true;\n        }\n        else if (this._textureBufferLength + 1 <= this._textureLimit)\n        {\n            this._textureBuffer[baseTexture.uid] = texture;\n            this._textureBufferLength += 1;\n\n            const newLength = this._textureIndexedBuffer.push(baseTexture);\n            const index = newLength - 1;\n\n            this._textureIndexMap[baseTexture.uid] = index;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _putAllTextures(textureArray: Array<PIXI.Texture>): boolean\n    {\n        let deltaBufferLength = 0;\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture: PIXI.BaseTexture = (textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i]) as PIXI.BaseTexture;\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                ++deltaBufferLength;\n            }\n        }\n\n        if (deltaBufferLength + this._textureBufferLength > this._textureLimit)\n        {\n            return false;\n        }\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture = textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i];\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                this._textureBuffer[texture.uid] = texture;\n                this._textureBufferLength += 1;\n\n                const newLength = this._textureIndexedBuffer.push(texture);\n                const index = newLength - 1;\n\n                this._textureIndexMap[texture.uid] = index;\n            }\n        }\n\n        return true;\n    }\n}\n\nexport default StdBatchFactory;\n","import { AttributeRedirect } from './redirects/AttributeRedirect';\nimport * as PIXI from 'pixi.js';\nimport Redirect from './redirects/Redirect';\nimport BatchRenderer from './BatchRenderer';\nimport { StdBatch } from './StdBatch';\nimport { AggregateUniformsBatch } from './AggregateUniformsBatch';\n\n// BatchGeometryFactory uses this class internally to setup the attributes of\n// the batches.\n//\n// Supports Uniforms+Standard Pipeline's in-batch/uniform ID.\nexport class BatchGeometry extends PIXI.Geometry\n{\n    // Interleaved attribute data buffer\n    attribBuffer: PIXI.Buffer;\n\n    // Batched indicies\n    indexBuffer: PIXI.Buffer;\n\n    constructor(attributeRedirects: AttributeRedirect[],\n        hasIndex: boolean,\n        texIDAttrib: string,\n        texturesPerObject: number,\n        inBatchIDAttrib: string,\n        uniformIDAttrib: string,\n    )\n    {\n        super();\n\n        const attributeBuffer = new PIXI.Buffer(null, false, false);\n        const indexBuffer = hasIndex ? new PIXI.Buffer(null, false, true) : null;\n\n        attributeRedirects.forEach((redirect) =>\n        {\n            const { glslIdentifer, glType, glSize, normalize } = redirect;\n\n            this.addAttribute(glslIdentifer, attributeBuffer, glSize, normalize, glType);\n        });\n\n        if (texIDAttrib && texturesPerObject > 0)\n        {\n            this.addAttribute(texIDAttrib, attributeBuffer, texturesPerObject, true, PIXI.TYPES.FLOAT);\n        }\n        if (inBatchIDAttrib)\n        {\n            this.addAttribute(inBatchIDAttrib, attributeBuffer, 1, false, PIXI.TYPES.FLOAT);\n        }\n        if (uniformIDAttrib)\n        {\n            this.addAttribute(uniformIDAttrib, attributeBuffer, 1, false, PIXI.TYPES.FLOAT);\n        }\n\n        if (hasIndex)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.attribBuffer = attributeBuffer;\n        this.indexBuffer = indexBuffer;\n    }\n}\n\n// To define the constructor shape, this is defined as an abstract class but documented\n// as an interface.\nexport abstract class IBatchGeometryFactory\n{\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor, @typescript-eslint/no-unused-vars\n    constructor(renderer: BatchRenderer)\n    {\n        // Implementation\n    }\n\n    abstract init(verticesBatched: number, indiciesBatched: number): void;\n    abstract append(displayObject: PIXI.DisplayObject, batch: any): void;\n    abstract build(): PIXI.Geometry;\n    abstract release(geom: PIXI.Geometry): void;\n}\n\n/**\n * This interface defines the methods you need to implement to creating your own batch\n * geometry factory.\n *\n * The constructor of an implementation should take only one argument - the batch renderer.\n *\n * @memberof PIXI.brend\n * @interface IBatchGeometryFactory\n */\n\n/**\n * Called before the batch renderer starts feeding the display-objects. This can be used\n * to pre-allocated space for the batch geometry.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method init\n * @param {number} verticesBatched\n * @param {number}[indiciesBatched] - optional when display-object's don't use a index buffer\n */\n\n/**\n * Adds the display-object to the batch geometry.\n *\n * If the display-object's shader also uses textures (in `uSamplers` uniform), then it will\n * be given a texture-ID to get the texture from the `uSamplers` array. If it uses multiple\n * textures, then the texture-ID is an array of indices into `uSamplers`. The texture-attrib\n * passed to the batch renderer sets the name of the texture-ID attribute (defualt is `aTextureId`).\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method append\n * @param {PIXI.DisplayObject} displayObject\n * @param {object} batch - the batch\n */\n\n/**\n * This should wrap up the batch geometry in a `PIXI.Geometry` object.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method build\n * @returns {PIXI.Geometry} batch geometry\n */\n\n/**\n * This is used to return a batch geometry so it can be pooled and reused in a future `build()`\n * call.\n *\n * @memberof PIXI.brend.IBatchGeometryFactory#\n * @method release\n * @param {PIXI.Geometry} geom\n */\n\n/**\n * Factory class that generates the geometry for a whole batch by feeding on\n * the individual display-object geometries. This factory is reusable, i.e. you\n * can build another geometry after a {@link build} call.\n *\n * **Optimizations:** To speed up geometry generation, this compiles an optimized\n * packing function that pushes attributes without looping through the attribute\n * redirects.\n *\n * **Default Format:** If you are not using a custom draw-call issuer, then\n * the batch geometry must have an interleaved attribute data buffer and one\n * index buffer.\n *\n * **Customization:** If you want to customize the batch geometry, then you must\n * also define your draw call issuer. This is not supported by pixi-batch-render\n * but is work-in-progress.\n *\n * **inBatchID Support**: If you specified an `inBatchID` attribute in the batch-renderer,\n * then this will support it automatically. The aggregate-uniforms pipeline doesn't need a custom\n * geometry factory.\n *\n * @memberof PIXI.brend\n * @class\n * @implements PIXI.brend.IBatchGeometryFactory\n */\nexport class BatchGeometryFactory extends IBatchGeometryFactory\n{\n    _targetCompositeAttributeBuffer: PIXI.ViewableBuffer;\n    _targetCompositeIndexBuffer: Uint16Array;\n    _aIndex: number;\n    _iIndex: number;\n\n    // These properties are not protected because GeometryMerger uses them!\n\n    // Standard Pipeline\n    _attribRedirects: AttributeRedirect[];\n    _indexProperty: string;\n    _vertexCountProperty: string | number;\n    _vertexSize: number;\n    _texturesPerObject: number;\n    _textureProperty: string;\n    _texIDAttrib: string;\n    _inBatchIDAttrib: string;\n    _inBatchID: number;\n\n    // Uniform+Standard Pipeline\n    _uniformIDAttrib: string;\n    _uniformID: number;\n\n    /* Set to the indicies of the display-object's textures in uSamplers uniform before\n        invoking geometryMerger(). */\n    protected _texID: number | number[];\n\n    protected _aBuffers: PIXI.ViewableBuffer[];\n    protected _iBuffers: Uint16Array[];\n\n    protected _geometryPool: Array<PIXI.Geometry>;\n\n    _geometryMerger: (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void;\n\n    /**\n     * @param {PIXI.brend.BatchRenderer} renderer\n     */\n    constructor(renderer: BatchRenderer)\n    {\n        super(renderer);\n\n        this._targetCompositeAttributeBuffer = null;\n        this._targetCompositeIndexBuffer = null;\n        this._aIndex = 0;\n        this._iIndex = 0;\n\n        this._attribRedirects = renderer._attribRedirects;\n        this._indexProperty = renderer._indexProperty;\n        this._vertexCountProperty = renderer._vertexCountProperty;\n        this._vertexSize = AttributeRedirect.vertexSizeFor(this._attribRedirects);\n        this._texturesPerObject = renderer._texturesPerObject;\n        this._textureProperty = renderer._textureProperty;\n        this._texIDAttrib = renderer._texIDAttrib;\n\n        this._inBatchIDAttrib = renderer._inBatchIDAttrib;\n        this._uniformIDAttrib = renderer._uniformIDAttrib;\n\n        this._vertexSize += this._texturesPerObject * 4;// texture indices are also passed\n\n        if (this._inBatchIDAttrib)\n        {\n            this._vertexSize += 4;\n        }\n        if (this._uniformIDAttrib)\n        {\n            this._vertexSize += 4;\n        }\n\n        if (this._texturesPerObject === 1)\n        {\n            this._texID = 0;\n        }\n        else if (this._texturesPerObject > 1)\n        {\n            this._texID = new Array(this._texturesPerObject);\n        }\n\n        this._aBuffers = [];// @see _getAttributeBuffer\n        this._iBuffers = [];// @see _getIndexBuffer\n\n        /**\n         * Batch geometries that can be reused.\n         *\n         * @member {PIXI.Geometry}\n         * @protected\n         * @see PIXI.brend.IBatchGeometryFactory#release\n         */\n        this._geometryPool = [];\n    }\n\n    /**\n     * Ensures this factory has enough space to buffer the given number of vertices\n     * and indices. This should be called before feeding display-objects from the\n     * batch.\n     *\n     * @param {number} verticesBatched\n     * @param {number} indiciesBatched\n     */\n    init(verticesBatched: number, indiciesBatched?: number): void\n    {\n        this._targetCompositeAttributeBuffer = this.getAttributeBuffer(verticesBatched);\n\n        if (this._indexProperty)\n        {\n            this._targetCompositeIndexBuffer = this.getIndexBuffer(indiciesBatched);\n        }\n\n        this._aIndex = this._iIndex = 0;\n    }\n\n    /**\n     * Append's the display-object geometry to this batch's geometry. You must override\n     * this you need to \"modify\" the geometry of the display-object before merging into\n     * the composite geometry (for example, adding an ID to a special uniform)\n     *\n     * @param {PIXI.DisplayObject} targetObject\n     * @param {number} batch\n     */\n    append(targetObject: PIXI.DisplayObject, batch_: any): void\n    {\n        const batch: StdBatch = batch_ as StdBatch;\n        const tex = (targetObject as any)[this._textureProperty];\n\n        // GeometryMerger uses _texID for texIDAttrib\n        if (this._texturesPerObject === 1)\n        {\n            const texUID = tex.baseTexture ? tex.baseTexture.uid : tex.uid;\n\n            this._texID = batch.uidMap[texUID];\n        }\n        else if (this._texturesPerObject > 1)\n        {\n            let _tex;\n\n            for (let k = 0; k < tex.length; k++)\n            {\n                _tex = tex[k];\n\n                const texUID = _tex.BaseTexture ? _tex.baseTexture.uid : _tex.uid;\n\n                (this._texID as number[])[k] = batch.uidMap[texUID];\n            }\n        }\n\n        // GeometryMerger uses this\n        if (this._inBatchIDAttrib)\n        {\n            this._inBatchID = batch.batchBuffer.indexOf(targetObject);\n        }\n        if (this._uniformIDAttrib)\n        {\n            this._uniformID = (batch as AggregateUniformsBatch).uniformMap[this._inBatchID];\n        }\n\n        this.geometryMerger(targetObject, this);\n    }\n\n    /**\n     * @override\n     * @returns {PIXI.Geometry} the generated batch geometry\n     * @example\n     * build(): PIXI.Geometry\n     * {\n     *      // Make sure you're not allocating new geometries if _geometryPool has some\n     *      // already. (Otherwise, a memory leak will result!)\n     *      const geom: ExampleGeometry = (this._geometryPool.pop() || new ExampleGeometry(\n     *          // ...your arguments... //)) as ExampleGeometry;\n     *\n     *      // Put data into geometry's buffer\n     *\n     *      return geom;\n     * }\n     */\n    build(): PIXI.Geometry\n    {\n        const geom: BatchGeometry = (this._geometryPool.pop() || new BatchGeometry(\n            this._attribRedirects,\n            true,\n            this._texIDAttrib,\n            this._texturesPerObject,\n            this._inBatchIDAttrib,\n            this._uniformIDAttrib,\n        )) as BatchGeometry;\n\n        // We don't really have to remove the buffers because BatchRenderer won't reuse\n        // the data in these buffers after the next build() call.\n        geom.attribBuffer.update(this._targetCompositeAttributeBuffer.float32View);\n        geom.indexBuffer.update(this._targetCompositeIndexBuffer);\n\n        return geom;\n    }\n\n    /**\n     * @param {PIXI.Geometry} geom - releases back the geometry to be reused. It is expected\n     *  that it is not used externally again.\n     * @override\n     */\n    release(geom: PIXI.Geometry): void\n    {\n        this._geometryPool.push(geom);\n    }\n\n    /**\n     * This lazy getter returns the geometry-merger function. This function\n     * takes one argument - the display-object to be appended to the batch -\n     * and pushes its geometry to the batch geometry.\n     *\n     * You can overwrite this property with a custom geometry-merger function\n     * if customizing `PIXI.brend.BatchGeometryFactory`.\n     *\n     * @member {PIXI.brend#IGeometryMerger}\n     */\n    protected get geometryMerger(): (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void\n    {\n        if (!this._geometryMerger)\n        {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            this._geometryMerger = new GeometryMergerFactory(this).compile();\n        }\n\n        return this._geometryMerger;\n    }\n    // eslint-disable-next-line require-jsdoc\n    protected set geometryMerger(func: (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void)\n    {\n        this._geometryMerger = func;\n    }\n\n    /**\n     * Allocates an attribute buffer with sufficient capacity to hold `size` elements.\n     *\n     * @param {number} size\n     * @protected\n     */\n    protected getAttributeBuffer(size: number): PIXI.ViewableBuffer\n    {\n        // 8 vertices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 8));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 8;\n\n        if (this._aBuffers.length <= roundedSizeIndex)\n        {\n            this._aBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._aBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._aBuffers[roundedSize] = buffer = new PIXI.ViewableBuffer(roundedSize * this._vertexSize);\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Allocates an index buffer (`Uint16Array`) with sufficient capacity to hold `size` indices.\n     *\n     * @param size\n     * @protected\n     */\n    protected getIndexBuffer(size: number): Uint16Array\n    {\n        // 12 indices is enough for 2 quads\n        const roundedP2 = PIXI.utils.nextPow2(Math.ceil(size / 12));\n        const roundedSizeIndex = PIXI.utils.log2(roundedP2);\n        const roundedSize = roundedP2 * 12;\n\n        if (this._iBuffers.length <= roundedSizeIndex)\n        {\n            this._iBuffers.length = roundedSizeIndex + 1;\n        }\n\n        let buffer = this._iBuffers[roundedSizeIndex];\n\n        if (!buffer)\n        {\n            this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);\n        }\n\n        return buffer;\n    }\n}\n\n// GeometryMergerFactory uses these variable names.\nconst CompilerConstants = {\n    INDICES_OFFSET: '__offset_indices_',\n    FUNC_SOURCE_BUFFER: 'getSourceBuffer',\n\n    // Argument names for the geometryMerger() function.\n    packerArguments: [\n        'targetObject',\n        'factory',\n    ],\n};\n\n// This was intended to be an inner class of BatchGeometryFactory; however, due to\n// a bug in JSDoc, it was placed outside.\n// https://github.com/jsdoc/jsdoc/issues/1673\n\n// Factory for generating a geometry-merger function (which appends the geometry of\n// a display-object to the batch geometry).\nconst GeometryMergerFactory = class\n{\n    packer: BatchGeometryFactory;\n\n    // We need the BatchGeometryFactory for attribute redirect information.\n    constructor(packer: BatchGeometryFactory)\n    {\n        this.packer = packer;\n    }\n\n    compile(): (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void\n    {\n        const packer = this.packer;\n\n        // The function's body/code is placed here.\n        let packerBody = ``;\n\n        // Define __offset_${i}, the offset of each attribute in the display-object's\n        // geometry, __buffer_${i} the source buffer of the attribute data.\n        packer._attribRedirects.forEach((redirect, i) =>\n        {\n            packerBody += `\n                let __offset_${i} = 0;\n                const __buffer_${i} = (\n                    ${this._compileSourceBufferExpression(redirect, i)});\n            `;\n        });\n\n        // This loops through each vertex in the display-object's geometry and appends\n        // them (attributes are interleaved, so each attribute element is pushed per vertex)\n        packerBody += `\n            const compositeAttributes = factory._targetCompositeAttributeBuffer;\n            const compositeIndices = factory._targetCompositeIndexBuffer;\n            let aIndex = factory._aIndex;\n            let iIndex = factory._iIndex;\n            const textureId = factory._texID;\n            const attributeRedirects = factory.attributeRedirects;\n\n            const {\n                int8View,\n                uint8View,\n                int16View,\n                uint16View,\n                int32View,\n                uint32View,\n                float32View,\n            } = compositeAttributes;\n\n            const vertexCount = ${this._compileVertexCountExpression()};\n\n            let adjustedAIndex = 0;\n\n            for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++)\n            {\n        `;\n\n        // Eliminate offset conversion when adjacent attributes\n        // have similar source-types.\n        let skipByteIndexConversion = false;\n\n        // Appends a vertice's attributes (inside the for-loop above).\n        for (let i = 0; i < packer._attribRedirects.length; i++)\n        {\n            const redirect = packer._attribRedirects[i];\n\n            // Initialize adjustedAIndex in terms of source type.\n            if (!skipByteIndexConversion)\n            {\n                packerBody += `\n        adjustedAIndex = aIndex / ${this._sizeOf(i)};\n                `;\n            }\n\n            if (typeof redirect.size === 'number')\n            {\n                for (let j = 0; j < redirect.size; j++)\n                {\n                    packerBody += `\n        ${redirect.type}View[adjustedAIndex++] = __buffer_${i}[__offset_${i}++];\n                    `;\n                }\n            }\n            else\n            {\n                packerBody += `\n        ${redirect.type}View[adjustedAIndex++] = __buffer_${i};\n                `;\n            }\n\n            if (packer._attribRedirects[i + 1] && (this._sizeOf(i + 1) !== this._sizeOf(i)))\n            {\n                packerBody += `\n        aIndex = adjustedAIndex * ${this._sizeOf(i)};\n                `;\n            }\n            else\n            {\n                skipByteIndexConversion = true;\n            }\n        }\n\n        if (skipByteIndexConversion)\n        {\n            if (this._sizeOf(packer._attribRedirects.length - 1) !== 4)\n            {\n                packerBody += `\n        aIndex = adjustedAIndex * ${this._sizeOf(packer._attribRedirects.length - 1)}\n                `;\n                skipByteIndexConversion = false;\n            }\n        }\n\n        if (packer._texturesPerObject > 0)\n        {\n            if (packer._texturesPerObject > 1)\n            {\n                if (!skipByteIndexConversion)\n                {\n                    packerBody += `\n        adjustedAIndex = aIndex / 4;\n                    `;\n                }\n\n                for (let k = 0; k < packer._texturesPerObject; k++)\n                {\n                    packerBody += `\n        float32View[adjustedAIndex++] = textureId[${k}];\n                    `;\n                }\n\n                packerBody += `\n        aIndex = adjustedAIndex * 4;\n                `;\n            }\n            else if (!skipByteIndexConversion)\n            {\n                packerBody += `\n        float32View[aIndex / 4] = textureId;\n                `;\n            }\n            else\n            {\n                packerBody += `\n        float32View[adjustedAIndex++] = textureId;\n        aIndex = adjustedAIndex * 4;\n                `;\n            }\n        }\n        if (packer._inBatchIDAttrib)\n        {\n            packerBody += `\n                float32View[adjustedAIndex++] = factory._inBatchID;\n                aIndex = adjustedAIndex * 4;\n            `;\n        }\n        if (packer._uniformIDAttrib)\n        {\n            packerBody += `\n                float32View[adjustedAIndex++] = factory._uniformID;\n                aIndex = adjustedAIndex * 4;\n            `;\n        }\n\n        /* Close the packing for-loop. */\n        packerBody += `}\n            ${this.packer._indexProperty\n        ? `const oldAIndex = this._aIndex;`\n        : ''}\n            this._aIndex = aIndex;\n        `;\n\n        if (this.packer._indexProperty)\n        {\n            packerBody += `\n    const verticesBefore = oldAIndex / ${this.packer._vertexSize}\n    const indexCount  = targetObject['${this.packer._indexProperty}'].length;\n\n    for (let j = 0; j < indexCount; j++)\n    {\n        compositeIndices[iIndex++] = verticesBefore + targetObject['${this.packer._indexProperty}'][j];\n    }\n\n    this._iIndex = iIndex;\n            `;\n        }\n\n        // eslint-disable-next-line no-new-func\n        return new Function(\n            ...CompilerConstants.packerArguments,\n            packerBody) as\n        (displayObject: PIXI.DisplayObject, factory: BatchGeometryFactory) => void;\n    }\n\n    // Returns an expression that fetches the attribute data source from\n    // targetObject (DisplayObject).\n    _compileSourceBufferExpression(redirect: Redirect, i: number): string\n    {\n        return (typeof redirect.source === 'string')\n            ? `targetObject['${redirect.source}']`\n            : `attributeRedirects[${i}].source(targetObject)`;\n    }\n\n    _compileVertexCountExpression(): string\n    {\n        if (!this.packer._vertexCountProperty)\n        {\n            // auto-calculate based on primary attribute\n            return `__buffer_0.length / ${\n                this.packer._attribRedirects[0].size}`;\n        }\n\n        return (\n            (typeof this.packer._vertexCountProperty === 'string')\n                ? `targetObject.${this.packer._vertexCountProperty}`\n                : `${this.packer._vertexCountProperty}`\n        );\n    }\n\n    _sizeOf(i: number): number\n    {\n        return PIXI.ViewableBuffer.sizeOf(\n            this.packer._attribRedirects[i].type);\n    }\n};\n\nexport default BatchGeometryFactory;\n","import * as PIXI from 'pixi.js';\n\nexport function resolveConstantOrProperty(targetObject: PIXI.DisplayObject, property: string | number): any\n{\n    return (typeof property === 'string')\n        ? targetObject[property]\n        : property;\n}\n\nexport default resolveConstantOrProperty;\n","import * as PIXI from 'pixi.js';\n\nexport function resolveFunctionOrProperty(targetObject: PIXI.DisplayObject, property: Function | string): any\n{\n    return (typeof property === 'string')\n        ? targetObject[property]\n        : property(targetObject);\n}\n\nexport default resolveFunctionOrProperty;\n","import BatchRenderer from './BatchRenderer';\n\n/**\n * Executes the final stage of batch rendering - drawing. The drawer can assume that\n * all display-objects have been into the batch-factory and the batch-geometry factory.\n *\n * @memberof PIXI.brend\n * @class\n */\nexport class BatchDrawer\n{\n    renderer: BatchRenderer;\n\n    constructor(renderer: BatchRenderer)\n    {\n        /**\n         * @member {PIXI.brend.BatchRenderer}\n         */\n        this.renderer = renderer;\n    }\n\n    /**\n     * This method will be called after all display-object have been fed into the\n     * batch and batch-geometry factories.\n     *\n     * **Hint**: You will call some form of `BatchGeometryFactory#build`; be sure to release\n     * that geometry for reuse in next render pass via `BatchGeometryFactory#release(geom)`.\n     */\n    draw(): void\n    {\n        const {\n            renderer,\n            _batchFactory: batchFactory,\n            _geometryFactory: geometryFactory,\n            _indexProperty: indexProperty,\n        }  = this.renderer;\n\n        const batchList = batchFactory.access();\n        const batchCount = batchFactory.size();\n        const geom = geometryFactory.build();\n        const { gl } = renderer;\n\n        batchList[0].upload(renderer);\n        renderer.shader.bind(this.renderer._shader, false);\n        renderer.geometry.bind(geom);\n\n        for (let i = 0; i < batchCount; i++)\n        {\n            const batch = batchList[i];\n\n            batch.upload(renderer);\n            renderer.shader.bind(this.renderer._shader, false);\n\n            if (indexProperty)\n            {\n                // TODO: Get rid of the $indexCount black magic!\n                gl.drawElements(gl.TRIANGLES, batch.$indexCount, gl.UNSIGNED_SHORT, batch.geometryOffset * 2);\n            }\n            else\n            {\n                // TODO: Get rid of the $vertexCount black magic!\n                gl.drawArrays(gl.TRIANGLES, batch.geometryOffset, batch.$vertexCount);\n            }\n\n            batch.reset();\n        }\n\n        geometryFactory.release(geom);\n    }\n}\n","import { StdBatchFactory } from './StdBatchFactory';\nimport { BatchGeometryFactory } from './BatchGeometryFactory';\nimport * as PIXI from 'pixi.js';\nimport { resolveConstantOrProperty, resolveFunctionOrProperty } from './resolve';\nimport { AttributeRedirect } from './redirects/AttributeRedirect';\nimport { BatchDrawer } from './BatchDrawer';\nimport { UniformRedirect } from './redirects/UniformRedirect';\n\nexport interface IBatchRendererOptions\n{\n    // Standard pipeline\n    attribSet: AttributeRedirect[];\n    indexProperty: string;\n    vertexCountProperty?: string | number;\n    textureProperty: string;\n    texturesPerObject?: number;\n    texIDAttrib: string;\n    inBatchIDAttrib?: string;\n    stateFunction: (renderer: PIXI.DisplayObject) => PIXI.State;\n    shaderFunction: (renderer: BatchRenderer) => PIXI.Shader;\n\n    // Components\n    BatchFactoryClass?: typeof StdBatchFactory;\n    BatchGeometryFactoryClass?: typeof BatchGeometryFactory;\n    BatchDrawerClass?: typeof BatchDrawer;\n\n    // Uniforms+Standard Pipeline\n    uniformSet?: UniformRedirect[];\n    uniformIDAttrib?: string;\n}\n\n/**\n * This object renderer renders multiple display-objects in batches. It can greatly\n * reduce the number of draw calls issued per frame.\n *\n * ## Batch Rendering Pipeline\n *\n * The batch rendering pipeline consists of the following stages:\n *\n * * **Display-Object Buffering**: Each display-object is kept in a buffer until it fills up or a\n * flush is required.\n *\n * * **Batch Generation**: In a sliding window, display-object batches are generated based off of certain\n * constraints like GPU texture units and the uniforms used in each display-object. This is done using an\n * instance of {@link PIXI.brend.BatchFactory}.\n *\n * * **Geometry Composition**: The geometries of all display-objects are merged together in a\n * composite geometry. This is done using an instance of {@link PIXI.brend.BatchGeometryFactory}.\n *\n * * **Drawing**: Each batch is rendered in-order using `gl.draw*`. The textures and\n * uniforms of each display-object are uploaded as arrays. This is done using an instance of\n * {@link PIXI.brend.BatchDrawer}.\n *\n * Each stage in this pipeline can be configured by overriding the appropriate component and passing that\n * class to `BatchRendererPluginFactory.from*`.\n *\n * ## Shaders\n *\n * ### Shader templates\n *\n * Since the max. display-object count per batch is not known until the WebGL context is created,\n * shaders are generated at runtime by processing shader templates. A shader templates has \"%macros%\"\n * that are replaced by constants at runtime.\n *\n * To use shader templates, simply use {@link PIXI.brend.BatchShaderFactory#derive}. This will generate a\n * function that derives a shader from your template at runtime.\n *\n * ### Textures\n *\n * The batch renderer uploads textures in the `uniform sampler2D uSamplers[%texturesPerBatch%];`. The\n * `varying float vTextureId` defines the index into this array that holds the current display-object's\n * texture.\n *\n * ### Uniforms\n *\n * This renderer currently does not support customized uniforms for display-objects. This is a\n * work-in-progress feature.\n *\n * ## Learn more\n * This batch renderer uses the PixiJS object-renderer API to hook itself:\n *\n * 1. [PIXI.ObjectRenderer]{@link http://pixijs.download/release/docs/PIXI.ObjectRenderer.html}\n *\n * 2. [PIXI.AbstractBatchRenderer]{@link http://pixijs.download/release/docs/PIXI.AbstractBatchRenderer.html}\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.ObjectRenderer\n * @example\n * import * as PIXI from 'pixi.js';\n * import { BatchRendererPluginFactory } from 'pixi-batch-renderer';\n *\n * // Define the geometry of your display-object and create a BatchRenderer using\n * // BatchRendererPluginFactory. Register it as a plugin with PIXI.Renderer.\n * PIXI.Renderer.registerPlugin('ExampleBatchRenderer', BatchRendererPluginFactory.from(...));\n *\n * class ExampleObject extends PIXI.Container\n * {\n *     _render(renderer: PIXI.Renderer): void\n *     {\n *          // BatchRenderer will handle the whole rendering process for you!\n *          renderer.batch.setObjectRenderer(renderer.plugins['ExampleBatchRenderer']);\n *          renderer.plugins['ExampleBatchRenderer'].render(this);\n *     }\n * }\n */\nexport class BatchRenderer extends PIXI.ObjectRenderer\n{\n    // Standard pipeline\n    readonly _attribRedirects: AttributeRedirect[];\n    readonly _indexProperty: string;\n    readonly _vertexCountProperty: string | number;\n    readonly _textureProperty: string;\n    readonly _texturesPerObject: number;\n    readonly _texIDAttrib: string;\n    readonly _inBatchIDAttrib: string;\n    readonly _stateFunction: Function;\n    readonly _shaderFunction: Function;\n\n    // Uniforms+Standard Pipeline\n    readonly _uniformRedirects: UniformRedirect[];\n    readonly _uniformIDAttrib: string;\n\n    // API Visiblity Note: These properties are used by component/factories and must be public;\n    // however, they are prefixed with an underscore because they are not for exposure to the end-user.\n\n    // Components\n    _batchFactory: StdBatchFactory;\n    _geometryFactory: BatchGeometryFactory;\n    _drawer: BatchDrawer;\n\n    // Display-object buffering\n    _objectBuffer: PIXI.DisplayObject[];\n    _bufferedVertices: number;\n    _bufferedIndices: number;\n\n    // Drawer\n    _shader: PIXI.Shader;\n\n    // WebGL Context config\n    MAX_TEXTURES: number;\n\n    // Component ctors\n    protected readonly _BatchFactoryClass: typeof StdBatchFactory;\n    protected readonly _BatchGeometryFactoryClass: typeof BatchGeometryFactory;\n    protected readonly _BatchDrawerClass: typeof BatchDrawer;\n\n    // Additional args\n    protected readonly options: any;\n\n    /**\n     * Creates a batch renderer the renders display-objects with the described geometry.\n     *\n     * To register a batch-renderer plugin, you must use the API provided by `PIXI.brend.BatchRendererPluginFactory`.\n     *\n     * @param {PIXI.Renderer} renderer - renderer to attach to\n     * @param {object} options\n     * @param {PIXI.brend.AttributeRedirect[]} options.attribSet\n     * @param {string | null} options.indexProperty\n     * @param {string | number} [options.vertexCountProperty]\n     * @param {string | null} options.textureProperty\n     * @param {number} [options.texturesPerObject=1]\n     * @param {string} options.texIDAttrib - name of texture-id attribute variable\n     * @param {Function} options.stateFunction - returns a PIXI.State for an object\n     * @param {Function} options.shaderFunction - generates a shader given this instance\n     * @param {Class} [options.BatchGeometryFactory=PIXI.brend.BatchGeometry]\n     * @param {Class} [options.BatchFactoryClass=PIXI.brend.StdBatchFactory]\n     * @param {Class} [options.BatchDrawer=PIXI.brend.BatchDrawer]\n     * @see PIXI.brend.BatchShaderFactory\n     * @see PIXI.brend.StdBatchFactory\n     * @see PIXI.brend.BatchGeometryFactory\n     * @see PIXI.brend.BatchDrawer\n     */\n    constructor(renderer: PIXI.Renderer, options: IBatchRendererOptions)\n    {\n        super(renderer);\n\n        /**\n         * Attribute redirects\n         * @member {PIXI.brend.AttributeRedirect[]}\n         * @protected\n         * @readonly\n         */\n        this._attribRedirects = options.attribSet;\n\n        /**\n         * Indices property\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._indexProperty = options.indexProperty;\n\n        /**\n         * Vertex count property (optional)\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._vertexCountProperty = options.vertexCountProperty;\n\n        /**\n         * Texture(s) property\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._textureProperty = options.textureProperty;\n\n        /**\n         * Textures per display-object\n         * @member {number}\n         * @protected\n         * @readonly\n         * @default 1\n         */\n        this._texturesPerObject = typeof options.texturesPerObject !== 'undefined' ? options.texturesPerObject : 1;\n\n        /**\n         * Texture ID attribute\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._texIDAttrib = options.texIDAttrib;\n\n        /**\n         * Indexes the display-object in the batch.\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._inBatchIDAttrib = options.inBatchIDAttrib;\n\n        /**\n         * State generating function (takes a display-object)\n         * @member {Function}\n         * @default () => PIXI.State.for2d()\n         * @protected\n         * @readonly\n         */\n        this._stateFunction = options.stateFunction || ((): PIXI.State => PIXI.State.for2d());\n\n        /**\n         * Shader generating function (takes the batch renderer)\n         * @member {Function}\n         * @protected\n         * @see PIXI.brend.BatchShaderFactory\n         * @readonly\n         */\n        this._shaderFunction = options.shaderFunction;\n\n        /**\n         * Batch-factory class.\n         * @member {Class}\n         * @protected\n         * @default PIXI.brend.StdBatchFactory\n         * @readonly\n         */\n        this._BatchFactoryClass = options.BatchFactoryClass || StdBatchFactory;\n\n        /**\n         * Batch-geometry factory class. Its constructor takes one argument - this batch renderer.\n         * @member {Class}\n         * @protected\n         * @default PIXI.brend.BatchGeometryFactory\n         * @readonly\n         */\n        this._BatchGeometryFactoryClass = options.BatchGeometryFactoryClass || BatchGeometryFactory;\n\n        /**\n         * Batch drawer class. Its constructor takes one argument - this batch renderer.\n         * @member {Class}\n         * @protected\n         * @default PIXI.brend.BatchDrawer\n         * @readonly\n         */\n        this._BatchDrawerClass = options.BatchDrawerClass || BatchDrawer;\n\n        /**\n         * Uniform redirects. If you use uniforms in your shader, be sure to use one the compatible\n         * batch factories (like `PIXI.brend.AggregateUniformsBatchFactory`).\n         * @member {PIXI.brend.UniformRedirect[]}\n         * @protected\n         * @default null\n         * @readonly\n         */\n        this._uniformRedirects = options.uniformSet || null;\n\n        /**\n         * Indexes the uniforms of the display-object in the uniform arrays. This is not equal to the\n         * in-batch ID because equal uniforms are not uploaded twice.\n         * @member {string}\n         * @protected\n         * @readonly\n         */\n        this._uniformIDAttrib = options.uniformIDAttrib;\n\n        /**\n         * The options used to create this batch renderer.\n         * @readonly {object}\n         * @protected\n         * @readonly\n         */\n        this.options = options;\n\n        // Although the runners property is not a public API, it is required to\n        // handle contextChange events.\n        this.renderer.runners.contextChange.add(this);\n\n        // If the WebGL context has already been created, initialization requires a\n        // syntheic call to contextChange.\n        if (this.renderer.gl)\n        {\n            this.contextChange();\n        }\n\n        this._objectBuffer = [];\n        this._bufferedVertices = 0;\n        this._bufferedIndices = 0;\n        this._shader = null;\n    }\n\n    /**\n     * Internal method that is called whenever the renderer's WebGL context changes.\n     */\n    contextChange(): void\n    {\n        const gl = this.renderer.gl;\n\n        if (PIXI.settings.PREFER_ENV === PIXI.ENV.WEBGL_LEGACY)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), PIXI.settings.SPRITE_MAX_TEXTURES);\n        }\n\n        /**\n         * @member {_BatchFactoryClass}\n         * @readonly\n         * @protected\n         */\n        this._batchFactory = new this._BatchFactoryClass(this);\n\n        /**\n         * @member {_BatchGeometryFactoryClass}\n         * @readonly\n         * @protected\n         */\n        this._geometryFactory = new this._BatchGeometryFactoryClass(this);\n\n        /**\n         * @member {_BatchDrawerClass}\n         * @readonly\n         * @protected\n         */\n        this._drawer = new this._BatchDrawerClass(this);\n    }\n\n    /**\n     * This is an internal method. It ensures that the batch renderer is ready to start buffering display-objects.\n     * This is automatically invoked by the renderer's batch system.\n     *\n     * @override\n     */\n    start(): void\n    {\n        this._objectBuffer.length = 0;\n        this._bufferedVertices = 0;\n        this._bufferedIndices = 0;\n\n        this._shader = this._shaderFunction(this);\n    }\n\n    /**\n     * Adds the display-object to be rendered in a batch. Your display-object's render/_render method should call\n     * this as follows:\n     *\n     * ```js\n     * renderer.setObjectRenderer(<BatchRenderer>);\n     * <BatchRenderer>.render(this);\n     * ```\n     *\n     * @param {PIXI.DisplayObject} displayObject\n     * @override\n     */\n    render(displayObject: PIXI.DisplayObject): void\n    {\n        this._objectBuffer.push(displayObject);\n\n        this._bufferedVertices += this._vertexCountFor(displayObject);\n\n        if (this._indexProperty)\n        {\n            this._bufferedIndices += resolveConstantOrProperty(displayObject, this._indexProperty).length;\n        }\n    }\n\n    /**\n     * Forces buffered display-objects to be rendered immediately. This should not be called unless absolutely\n     * necessary like the following scenarios:\n     *\n     * * before directly rendering your display-object, to preserve render-order.\n     *\n     * * to do a nested render pass (calling `Renderer#render` inside a `render` method)\n     *   because the PixiJS renderer is not re-entrant.\n     *\n     * @override\n     */\n    flush(): void\n    {\n        const { _batchFactory: batchFactory, _geometryFactory: geometryFactory, _stateFunction: stateFunction } = this;\n        const buffer = this._objectBuffer;\n        const bufferLength = buffer.length;\n\n        // Reset components\n        batchFactory.reset();\n        geometryFactory.init(this._bufferedVertices, this._bufferedIndices);\n\n        let batchStart = 0;\n\n        // Loop through display-objects and create batches\n        for (let objectIndex = 0; objectIndex < bufferLength;)\n        {\n            const target = buffer[objectIndex];\n            const wasPut = batchFactory.put(target, resolveFunctionOrProperty(target, stateFunction));\n\n            if (!wasPut)\n            {\n                batchFactory.build(batchStart);\n                batchStart = objectIndex;\n            }\n            else\n            {\n                ++objectIndex;\n            }\n        }\n\n        // Generate the last batch, if required.\n        if (!batchFactory.ready())\n        {\n            batchFactory.build(batchStart);\n        }\n\n        const batchList = batchFactory.access();\n        const batchCount = batchFactory.size();\n        let indices = 0;\n\n        // Loop through batches and their display-object list to compose geometry\n        for (let i = 0; i < batchCount; i++)// loop-per(batch)\n        {\n            const batch = batchList[i];\n            const batchBuffer = batch.batchBuffer;\n            const batchLength = batchBuffer.length;\n\n            let vertexCount = 0;\n            let indexCount = 0;\n\n            for (let j = 0; j < batchLength; j++)// loop-per(targetObject)\n            {\n                const targetObject = batchBuffer[j];\n\n                if (this._indexProperty)\n                {\n                    indexCount += resolveConstantOrProperty(targetObject, this._indexProperty).length;\n                }\n                else\n                {\n                    vertexCount += resolveConstantOrProperty(targetObject, this._vertexCountProperty);\n                }\n\n                // externally-defined properties for draw calls\n                batch.$vertexCount = vertexCount;\n                batch.$indexCount = indexCount;\n                batch.geometryOffset = indices;\n                indices += batch.$indexCount;\n\n                geometryFactory.append(targetObject, batch);\n            }\n        }\n\n        // BatchDrawer handles the rest!\n        this._drawer.draw();\n    }\n\n    /**\n     * Internal method that stops buffering of display-objects and flushes any existing buffers.\n     *\n     * @override\n     */\n    stop(): void\n    {\n        if (this._bufferedVertices)\n        {\n            this.flush();\n        }\n    }\n\n    // Should we document this?\n    protected _vertexCountFor(targetObject: PIXI.DisplayObject): number\n    {\n        return (this._vertexCountProperty)\n            ? resolveConstantOrProperty(targetObject, this._vertexCountProperty)\n            : resolveFunctionOrProperty(targetObject,\n                this._attribRedirects[0].source).length\n                    / (this._attribRedirects[0].size as number);\n    }\n}\n\nexport default BatchRenderer;\n","import { BatchRenderer } from './BatchRenderer';\nimport { AttributeRedirect } from './redirects/AttributeRedirect';\nimport BatchGeometryFactory from './BatchGeometryFactory';\nimport StdBatchFactory from './StdBatchFactory';\n\nimport * as PIXI from 'pixi.js';\nimport { BatchDrawer } from './BatchDrawer';\nimport { UniformRedirect } from './redirects';\n\n// (Uniforms?)+Geometry+Textures is the standard pipeline in Pixi's AbstractBatchRenderer.\ninterface IBatchRendererStdOptions\n{\n    attribSet: AttributeRedirect[];\n    vertexCountProperty: string | number;\n    indexProperty: string;\n    textureProperty: string;\n    texturesPerObject?: number;\n    texIDAttrib: string;\n    inBatchIDAttrib?: string;\n    stateFunction: (brend: PIXI.DisplayObject) => any;\n    shaderFunction: (brend: BatchRenderer) => any;\n    geometryFactory: BatchGeometryFactory;\n    BatchFactoryClass?: typeof StdBatchFactory;\n    BatchRendererClass?: typeof BatchRenderer;\n    BatchGeometryFactoryClass?: typeof BatchGeometryFactory;\n    BatchDrawerFactoryClass?: typeof BatchDrawer;\n\n    uniformSet?: UniformRedirect[];\n    uniformIDAttrib?: string;\n}\n\n/**\n * Factory class for creating a batch-renderer.\n *\n * @memberof PIXI.brend\n * @class\n * @example\n *  import * as PIXI from 'pixi.js';\n *  import { AttributeRedirect, BatchShaderFactory, BatchRendererPluginFactory } from 'pixi-batch-renderer';\n *\n *  // Define the geometry of Sprite.\n *  const attribSet = [\n *      // Sprite vertexData contains global coordinates of the corners\n *      new AttributeRedirect({\n *          source: 'vertexData',\n *          attrib: 'aVertex',\n *          type: 'float32',\n *          size: 2,\n *          glType: PIXI.TYPES.FLOAT,\n *          glSize: 2,\n *      }),\n *      // Sprite uvs contains the normalized texture coordinates for each corner/vertex\n *      new AttributeRedirect({\n *          source: 'uvs',\n *          attrib: 'aTextureCoord',\n *          type: 'float32',\n *          size: 2,\n *          glType: PIXI.TYPES.FLOAT,\n *          glSize: 2,\n *      }),\n *  ];\n *\n *  const shaderFunction = new BatchShaderFactory(// 1. vertexShader\n *  `\n *  attribute vec2 aVertex;\n *  attribute vec2 aTextureCoord;\n *  attribute float aTextureId;\n *\n *  varying float vTextureId;\n *  varying vec2 vTextureCoord;\n *\n *  uniform mat3 projectionMatrix;\n *\n *  void main() {\n *      gl_Position = vec4((projectionMatrix * vec3(aVertex, 1)).xy, 0, 1);\n *      vTextureId = aTextureId;\n *      vTextureCoord = aTextureCoord;\n *  }\n *  `,\n *  `\n *  uniform sampler2D uSamplers[%texturesPerBatch%];\n *  varying float vTextureId;\n *  varying vec2 vTextureCoord;\n *\n *  void main(void){\n *      vec4 color;\n *\n *      // get color, which is the pixel in texture uSamplers[vTextureId] at vTextureCoord\n *      for (int k = 0; k < %texturesPerBatch%; ++k) {\n *          if (int(vTextureId) == k) {\n *              color = texture2D(uSamplers[k], vTextureCoord);\n *              break;\n *          }\n *      }\n *\n *      gl_FragColor = color;\n *  }\n *  `,\n *  {// we don't use any uniforms except uSamplers, which is handled by default!\n *  },\n *  // no custom template injectors\n *  // disable vertex shader macros by default\n *  ).derive();\n *\n *  // Produce the SpriteBatchRenderer class!\n *  const SpriteBatchRenderer = BatchRendererPluginFactory.from({\n *      attribSet,\n *      indexProperty: 'indices',\n *      textureProperty: 'texture',\n *      texturesPerObject: 1, // default\n *      texIDAttrib: 'aTextureId',\n *      stateFunction: () => PIXI.State.for2d(), // default\n *      shaderFunction\n *  });\n *\n *  PIXI.Renderer.registerPlugin('customBatch', SpriteBatchRenderer);\n *\n *  // Sprite will render using SpriteBatchRenderer instead of default PixiJS\n *  // batch renderer. Instead of targetting PIXI.Sprite, you can write a batch\n *  // renderer for a custom display-object too! (See main page for that example!)\n *  const exampleSprite = PIXI.Sprite.from('./asset/example.png');\n *  exampleSprite.pluginName = 'customBatch';\n *  exampleSprite.width = 128;\n *  exampleSprite.height = 128;\n */\nexport class BatchRendererPluginFactory\n{\n    /**\n     * Generates a fully customized `BatchRenderer` that aggregates primitives and textures. This is useful\n     * for non-uniform based display-objects.\n     *\n     * @param {object} options\n     * @param {PIXI.brend.AttributeRedirect[]} options.attribSet - set of geometry attributes\n     * @param {string | Array<number>} options.indexProperty - no. of indices on display-object\n     * @param {string | number} options.vertexCountProperty - no. of vertices on display-object\n     * @param {string} options.textureProperty - textures used in display-object\n     * @param {number} options.texturePerObject - no. of textures used per display-object\n     * @param {string} options.texIDAttrib - used to find texture for each display-object (index into array)\n     * @param {string | Function}[options.stateFunction= ()=>PIXI.State.for2d()] - callback that finds the WebGL\n     *  state required for display-object shader\n     * @param {Function} options.shaderFunction - shader generator function\n     * @param {Class}[options.BatchGeometryFactoryClass] - custom batch geometry factory class\n     * @param {Class} [options.BatchFactoryClass] - custom batch factory class\n     * @param {Class} [options.BatchRendererClass] - custom batch renderer class\n     * @param {Class} [options.BatchDrawerClass] - custom batch drawer class\n     * @static\n     */\n    static from(options: IBatchRendererStdOptions): typeof BatchRenderer\n    {\n        // This class wraps around BatchRendererClass's constructor and passes the options from the outer scope.\n        return class extends (options.BatchRendererClass || BatchRenderer)\n        {\n            constructor(renderer: PIXI.Renderer)\n            {\n                super(renderer, options);\n            }\n        };\n    }\n}\n\nexport default BatchRendererPluginFactory;\n","import * as PIXI from 'pixi.js';\nimport BatchRenderer from './BatchRenderer';\nimport { AggregateUniformsBatchFactory } from './AggregateUniformsBatchFactory';\n\n// This file might need a cleanup :)\n\n// JavaScript is stupid enough not to have a replaceAll in String. This is a temporary\n// solution and we should depend on an actually polyfill.\nfunction _replaceAll(target: string, search: string, replacement: string): string\n{\n    return target.replace(new RegExp(search, 'g'), replacement);\n}\n\nfunction injectTexturesPerBatch(batchRenderer: BatchRenderer): string\n{\n    return `${batchRenderer.MAX_TEXTURES}`;\n}\n\nconst INJECTORS = {\n    uniformsPerBatch(renderer: BatchRenderer): string\n    {\n        return `${(renderer._batchFactory as AggregateUniformsBatchFactory).MAX_UNIFORMS}`;\n    },\n};\n\n/**\n * Exposes an easy-to-use API for generating shader-functions to use in\n * the batch renderer!\n *\n * You are required to provide an injector map, which maps macros to functions\n * that return a string value for those macros given a renderer. By default, only one\n * injector is used - the textures per batch `%texturesPerBatch%` macro. This is replaced by\n * the number of textures passed to the `uSamplers` textures uniform.\n *\n * **Built-in Injectors**:\n *\n * * `%texturesPerBatch%`: replaced by the max. textures allowed by WebGL context\n *\n * * `%uniformsPerBatch%`: replaced by the (aggregate-uniforms) batch factory's `MAX_UNIFORMS` property.\n *\n * @memberof PIXI.brend\n * @class\n */\nexport class BatchShaderFactory\n{\n    protected _vertexShaderTemplate: string;\n    protected _fragmentShaderTemplate: string;\n    protected _uniforms: any;\n    protected _templateInjectors: any;\n\n    protected disableVertexShaderTemplate: boolean;\n\n    protected _cache: any;\n    protected _cState: any;\n\n    /**\n     * WARNING: Do not pass `uSamplers` in your uniforms. They\n     *  will be added to your shader instance directly.\n     *\n     * @param {string} vertexShaderTemplate\n     * @param {string} fragmentShaderTemplate\n     * @param {UniformGroup | Map<string, object>} uniforms\n     * @param {Object.<String, PIXI.brend.InjectorFunction>} [templateInjectors]\n     * @param {boolean} [disableVertexShaderTemplate=true] - turn off (true)\n     *      if you aren't using macros in the vertex shader\n     */\n    constructor(\n        vertexShaderTemplate: string,\n        fragmentShaderTemplate: string,\n        uniforms = {},\n        templateInjectors: any = {},\n        disableVertexShaderTemplate = true,\n    )\n    {\n        if (!templateInjectors['%texturesPerBatch%'])\n        {\n            templateInjectors['%texturesPerBatch%'] = injectTexturesPerBatch;\n        }\n        if (!templateInjectors['%uniformsPerBatch%'])\n        {\n            templateInjectors['%uniformsPerBatch%'] = INJECTORS.uniformsPerBatch;\n        }\n\n        this._vertexShaderTemplate = vertexShaderTemplate;\n        this._fragmentShaderTemplate = fragmentShaderTemplate;\n        this._uniforms = uniforms;\n        this._templateInjectors = templateInjectors;\n\n        /**\n         * Disable vertex shader templates to speed up shader\n         * generation.\n         *\n         * @member {Boolean}\n         */\n        this.disableVertexShaderTemplate = disableVertexShaderTemplate;\n\n        /**\n         * Maps the stringifed state of the batch renderer to the\n         * generated shader.\n         *\n         * @private\n         * @member {Object.<String, PIXI.Shader>}\n         */\n        this._cache = {};\n\n        /**\n         * Unstringifed current state of the batch renderer.\n         *\n         * @private\n         * @member {Object.<String, String>}\n         * @see {PIXI.brend.ShaderGenerator#_generateInjectorBasedState}\n         */\n        this._cState = null;\n    }\n\n    /**\n     * This essentially returns a function for generating the shader for a batch\n     * renderer.\n     *\n     * @return shader function that can be given to the batch renderer\n     */\n    derive(): (brend: BatchRenderer) => PIXI.Shader\n    {\n        return (batchRenderer: BatchRenderer): PIXI.Shader =>\n        {\n            const stringState = this._generateInjectorBasedState(batchRenderer);\n            const cachedShader = this._cache[stringState];\n\n            if (cachedShader)\n            {\n                return cachedShader;\n            }\n\n            return this._generateShader(stringState, batchRenderer);\n        };\n    }\n\n    protected _generateInjectorBasedState(batchRenderer: BatchRenderer): string\n    {\n        let state = '';\n        const cState = this._cState = {};\n\n        for (const injectorMacro in this._templateInjectors)\n        {\n            const val = this._templateInjectors[injectorMacro](batchRenderer);\n\n            state += val;\n            cState[injectorMacro] = val;\n        }\n\n        return state;\n    }\n\n    protected _generateShader(stringState: string, renderer: BatchRenderer): PIXI.Shader\n    {\n        let vertexShaderTemplate = this._vertexShaderTemplate.slice(0);\n\n        let fragmentShaderTemplate = this._fragmentShaderTemplate.slice(0);\n\n        for (const injectorTemplate in this._cState)\n        {\n            if (!this.disableVertexShaderTemplate)\n            {\n                vertexShaderTemplate = _replaceAll(vertexShaderTemplate,\n                    injectorTemplate, this._cState[injectorTemplate]);\n            }\n\n            fragmentShaderTemplate = _replaceAll(fragmentShaderTemplate,\n                injectorTemplate, this._cState[injectorTemplate]);\n        }\n\n        const shader = PIXI.Shader.from(vertexShaderTemplate,\n            fragmentShaderTemplate, this._uniforms);\n\n        const textures = new Array(renderer.MAX_TEXTURES);\n\n        for (let i = 0; i < textures.length; i++)\n        {\n            textures[i] = i;\n        }\n        shader.uniforms.uSamplers = textures;\n\n        this._cache[stringState] = shader;\n\n        return shader;\n    }\n}\n\nexport default BatchShaderFactory;\n","import { StdBatch } from './StdBatch';\nimport { UniformGroup } from 'pixi.js';\nimport BatchRenderer from './BatchRenderer';\n\n/**\n * Allows usage of uniforms when rendering display-objects in batches. It expects you to\n * aggregate each display-object's uniforms in an array and that the shader will pick\n * the appropriate uniform at runtime (an index into the uniforms array will be passed).\n *\n * **Usage in shader:**\n * ```\n * // Your display-objects' affine transforms are aggregated into this array.\n * uniform mat3d affineTransform[];\n *\n * // For WebGL1+ machines, your uniforms may be fetched by the uniform-ID attrib (float).\n * varying float vUniformID;\n *\n * // For WebGL-2 only, to prevent interpolation overhead, you may use the flat in variables. You\n * // can configure this in AggregateUniformShaderFactory.\n * flat in int uniformID;\n * ```\n *\n * # No Aggregation Mode\n *\n * Aggregating uniforms into arrays requries a uniform-ID attribute to be uploaded as well. This\n * may cost a lot of memory if your uniforms don't really change a lot. For these cases, you can\n * disable uniform aggregation by not passing a `uniformIDAttrib`. This will make batches **only**\n * have one value for each uniform. The uniforms will still be uploaded as 1-element arrays, however.\n *\n * @memberof PIXI.brend\n * @class\n * @extends PIXI.brend.StdBatch\n */\nexport class AggregateUniformsBatch extends StdBatch\n{\n    renderer: BatchRenderer;\n\n    uniformBuffer: { [id: string]: Array<UniformGroup> };\n    uniformMap: Array<number>;\n    uniformLength: number;\n\n    constructor(renderer: BatchRenderer, geometryOffset?: number)\n    {\n        super(geometryOffset);\n\n        /**\n         * Renderer holding the uniform redirects\n         * @member {PIXI.brend.BatchRenderer}\n         */\n        this.renderer = renderer;\n\n        /**\n         * The buffer of uniform arrays of the display-objects\n         * @member {Object<string, Array<UniformGroup>>}\n         */\n        this.uniformBuffer = null;\n\n        /**\n         * Array mapping the in-batch ID to the uniform ID.\n         * @member {Array<number>}\n         */\n        this.uniformMap = null;\n\n        /**\n         * No. of uniforms buffered (per uniform name)\n         * @member {number}\n         */\n        this.uniformLength = 0;\n    }\n\n    /**\n     * @param {PIXI.Renderer} renderer\n     * @override\n     */\n    upload(renderer: PIXI.Renderer): void\n    {\n        super.upload(renderer);\n\n        const { _uniformRedirects: uniformRedirects, _shader: shader } = this.renderer;\n\n        for (let i = 0, j = uniformRedirects.length; i < j; i++)\n        {\n            const glslIdentifer = uniformRedirects[i].glslIdentifer;\n\n            shader.uniforms[glslIdentifer] = this.uniformBuffer[glslIdentifer];\n        }\n\n        //        shader.uniformGroup.update();\n    }\n\n    /**\n     * @override\n     */\n    reset(): void\n    {\n        super.reset();\n\n        for (const uniformName in this.uniformBuffer)\n        {\n            this.uniformBuffer[uniformName].length = 0;\n        }\n    }\n}\n","import { StdBatchFactory } from './StdBatchFactory';\nimport { AggregateUniformsBatch } from './AggregateUniformsBatch';\nimport BatchRenderer from './BatchRenderer';\nimport * as PIXI from 'pixi.js';\n\n/**\n * Factory for producing aggregate-uniforms batches. This is useful for shaders that\n * **must** use uniforms.\n *\n * **Hint**: Use this with `PIXI.brend.AggregateUniformsBatchDrawer`.\n *\n * @memberof PIXI.brend.AggregateUniformsBatchFactory\n */\nexport class AggregateUniformsBatchFactory extends StdBatchFactory\n{\n    MAX_UNIFORMS: number;\n\n    protected uniformBuffer: { [id: string]: Array<PIXI.UniformGroup> };\n    protected uniformMap: Array<number>;\n    protected uniformLength: number;\n\n    constructor(renderer: BatchRenderer)\n    {\n        super(renderer);\n\n        /**\n         * The max. uniforms until the batch is filled\n         * @member {number}\n         * @readonly\n         */\n        // Max. no. of uniforms that can be passed to the batch shader. We divide by four because\n        // mat4d/vec4 count as four uniforms.\n        this.MAX_UNIFORMS = Math.floor(\n            Math.min(\n                renderer.renderer.gl.getParameter(renderer.renderer.gl.MAX_VERTEX_UNIFORM_VECTORS),\n                renderer.renderer.gl.getParameter(renderer.renderer.gl.MAX_FRAGMENT_UNIFORM_VECTORS))\n            / (4 * renderer._uniformRedirects.length));\n\n        this.uniformBuffer = this._createUniformBuffer();\n        this.uniformMap = [];\n        this.uniformLength = 0;\n    }\n\n    /**\n     * @returns {AggregateUniformsBatch}\n     */\n    _newBatch(): AggregateUniformsBatch\n    {\n        const batch = new AggregateUniformsBatch(this._renderer);\n\n        // All pooled batches will have a buffer\n        batch.uniformBuffer = this._createUniformBuffer();\n        batch.uniformMap = [];\n\n        return batch;\n    }\n\n    /**\n     * Stores uniforms in the current batch, if possible.\n     *\n     * If you want to override this, be sure to return beforehand if `super._put` returns\n     * false:\n     * ```\n     * _put(displayObject: PIXI.DisplayObject): boolean\n     * {\n     *      if (!super._put(displayObject))\n     *      {\n     *          return false;\n     *      }\n     *\n     *      // Your logic ...\n     * }\n     * ```\n     *\n     * @protected\n     * @param {PIXI.DisplayObject} displayObject\n     * @returns {boolean} - whether uniforms can be buffered\n     */\n    protected _put(displayObject: PIXI.DisplayObject): boolean\n    {\n        if (!this._renderer._uniformIDAttrib)\n        {\n            // No aggregation mode! If uniforms already buffered, they **must** match or batch will break.\n            if (this.uniformLength > 0)\n            {\n                const id = this._matchUniforms(displayObject);\n\n                if (id > 0)\n                {\n                    return true;\n                }\n\n                return false;\n            }\n        }\n\n        if (this.uniformLength + 1 >= this.MAX_UNIFORMS)\n        {\n            return false;\n        }\n\n        if (this._renderer._uniformIDAttrib)\n        {\n            const id = this._matchUniforms(displayObject);\n\n            if (id > 0)\n            {\n                this.uniformMap.push(id);\n\n                return true;\n            }\n        }\n\n        // Push each uniform into the buffer\n        for (let i = 0, j = this._renderer._uniformRedirects.length; i < j; i++)\n        {\n            const uniformRedirect = this._renderer._uniformRedirects[i];\n            const { source, glslIdentifer } = uniformRedirect;\n\n            this.uniformBuffer[glslIdentifer].push(typeof source === 'string'\n                ? (displayObject as any)[source] : source(displayObject));\n        }\n\n        this.uniformMap.push(this.uniformLength);\n        ++this.uniformLength;\n\n        return true;\n    }\n\n    /**\n     * @protected\n     * @param {AggregateUniformBatch} batch\n     */\n    _buildBatch(batch: any): void\n    {\n        super._buildBatch(batch);\n\n        const buffer = batch.uniformBuffer;\n        const map = batch.uniformMap;\n\n        batch.uniformBuffer = this.uniformBuffer;\n        batch.uniformMap = this.uniformMap;\n        batch.uniformLength = this.uniformLength;\n\n        // Swap & reset instead of new allocation\n        this.uniformBuffer = buffer;\n        this.uniformMap = map;\n        this.uniformLength = 0;\n        this._resetUniformBuffer(this.uniformBuffer);\n        this.uniformMap.length = 0;\n    }\n\n    /**\n     * Creates an array for each uniform-name in an object.\n     *\n     * @returns - the object created (the uniform buffer)\n     */\n    private _createUniformBuffer(): { [id: string]: Array<PIXI.UniformGroup> }\n    {\n        const buffer: { [id: string]: Array<PIXI.UniformGroup> } = {};\n\n        for (let i = 0, j = this._renderer._uniformRedirects.length; i < j; i++)\n        {\n            const uniformRedirect = this._renderer._uniformRedirects[i];\n\n            buffer[uniformRedirect.glslIdentifer] = [];\n        }\n\n        return buffer;\n    }\n\n    /**\n     * Resets each array in the uniform buffer\n     * @param {object} buffer\n     */\n    private _resetUniformBuffer(buffer: { [id: string]: Array<PIXI.UniformGroup> }): void\n    {\n        for (let i = 0, j = this._renderer._uniformRedirects.length; i < j; i++)\n        {\n            const uniformRedirect = this._renderer._uniformRedirects[i];\n\n            buffer[uniformRedirect.glslIdentifer].length = 0;\n        }\n    }\n\n    /**\n     * Finds a matching set of uniforms in the buffer.\n     */\n    private _matchUniforms(displayObject: any): number\n    {\n        const uniforms = this._renderer._uniformRedirects;\n\n        for (let i = this.uniformLength - 1; i >= 0; i--)\n        {\n            let isMatch = true;\n\n            for (let k = 0, n = uniforms.length; k < n; k++)\n            {\n                const { glslIdentifer, source } = uniforms[k];\n\n                const value = typeof source === 'string'\n                    ? displayObject[source]\n                    : source(displayObject as PIXI.DisplayObject);\n\n                if (!this._compareUniforms(value, this.uniformBuffer[glslIdentifer][i]))\n                {\n                    isMatch = false;\n                    break;\n                }\n            }\n\n            if (isMatch)\n            {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    // Compares two uniforms u1 & u2 for equality.\n    private _compareUniforms(u1: any, u2: any): boolean\n    {\n        if (u1 === u2)\n        {\n            return true;\n        }\n\n        // UniformGroups must have referential equality\n        if (u1.group || u2.group)\n        {\n            return false;\n        }\n\n        // Allow equals() method for custom stuff.\n        if (u1.equals)\n        {\n            return u1.equals(u2);\n        }\n\n        // Test one-depth equality for arrays\n        if (Array.isArray(u1) && Array.isArray(u2))\n        {\n            if (u1.length !== u2.length)\n            {\n                return false;\n            }\n\n            for (let i = 0, j = u1.length; i < j; i++)\n            {\n                // Referential equality for array elements\n                if (u1[i] !== u2[i])\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        if (u1 instanceof PIXI.Point && u2 instanceof PIXI.Point)\n        {\n            return u1.x === u2.x && u1.y === u2.y;\n        }\n        if (u1 instanceof PIXI.Matrix && u2 instanceof PIXI.Matrix)\n        {\n            return u1.a === u2.a && u1.b === u2.b\n                && u1.c === u2.c && u1.d === u2.d\n                && u1.tx === u2.tx && u1.ty === u2.ty;\n        }\n\n        // Unlikely for batch rendering\n        if (u1 instanceof PIXI.BaseTexture && u2 instanceof PIXI.BaseTexture)\n        {\n            return u1.uid === u2.uid;\n        }\n\n        return true;\n    }\n}\n","export * from './redirects';\nexport { StdBatchFactory as BatchGenerator } from './StdBatchFactory';\nexport { BatchRenderer } from './BatchRenderer';\nexport { BatchRendererPluginFactory } from './BatchRendererPluginFactory';\nexport { BatchGeometryFactory as GeometryPacker } from './BatchGeometryFactory';\nexport { Redirect } from './redirects/Redirect';\nexport { BatchShaderFactory } from './BatchShaderFactory';\nexport { StdBatch as Batch } from './StdBatch';\n\nexport * from './AggregateUniformsBatch';\nexport * from './AggregateUniformsBatchFactory';\n\n/**\n * @memberof PIXI\n * @namespace brend\n * @example\n * // ES6 import\n * import * as brend from 'pixi-batch-renderer';\n * const { BatchRendererPluginFactory } = brend;\n * @example\n * // CommonJS require\n * const brend = require('pixi-batch-renderer');\n * const BatchRendererPluginFactory = brend.BatchRendererPluginFactory;\n */\n\n/**\n * Used by `PIXI.brend.BatchGeometryFactory` to merge the geometry of a\n * display-object into the whole batch's geometry.\n *\n * @memberof PIXI.brend#\n * @function IGeometryMerger\n * @param {PIXI.DisplayObject} displayObject\n * @param {PIXI.brend.BatchGeometryFactory} factory\n * @see PIXI.brend.BatchGeometryFactory#geometryMerger\n */\n\n/**\n * @function\n * @name InjectorFunction\n * @memberof PIXI.brend\n *\n * @param {PIXI.brend.BatchRenderer} batchRenderer\n * @return {string} value of the macro for this renderer\n */\n"],"names":["PIXI.ViewableBuffer","PIXI.Geometry","PIXI.Buffer","PIXI.TYPES","PIXI.utils","PIXI.ObjectRenderer","PIXI.State","PIXI.settings","PIXI.ENV","PIXI.Shader","PIXI.Point","PIXI.Matrix","PIXI.BaseTexture"],"mappings":";;;;;;;;;AAEA;;;;;;;;;;MAUsB,QAAQ;IAK1B,YAAY,MAA6D,EAAE,aAAqB;;;;;;;;;QAU5F,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;;;;;;QAOrB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;KACtC;;;ACrBL;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2Ba,iBAAkB,SAAQ,QAAQ;;;;;;;;;;;IAoB3C,YAAY,OAAkC;QAE1C,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;;;;;;;;;QAUtC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;;;;;;;;;;QAWzB,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;;;;;;QAOzB,IAAI,CAAC,UAAU,GAAG,CAAC,OAAO,CAAC,IAAI,KAAK,YAAY,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC;;;;;;;;;;;;;QAcnG,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;;;;;;;QAS7B,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;;;;;;;QAQ7B,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC;KACxC;IAED,OAAO,aAAa,CAAC,kBAA4C;QAE7D,OAAO,kBAAkB,CAAC,MAAM,CAC5B,CAAC,GAAG,EAAE,QAAQ,KACV,CAACA,cAAmB,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC;cACpC,QAAQ,CAAC,UAAU;cACvB,GAAG,EACT,CAAC,CAAC,CAAC;KACV;;;AC5HL;;;;;;;;;;;;;;MAca,eAAgB,SAAQ,QAAQ;IAEzC,YAAY,OAAgC;QAExC,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;KAC1C;;;AC1BL;;;;;;;;;;MAUa,QAAQ;IASjB,YAAY,cAAuB;;;;;;QAO/B,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;;;;;;QAOrC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;;;;;;QAO1B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;;;;;;QAOnB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;KACrB;;;;;;;IAQD,MAAM,CAAC,QAAuB;QAE1B,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC;YAE9B,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;SACjC,CAAC,CAAC;QAEH,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAClC;;;;IAKD,KAAK;QAED,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAErD,IAAI,IAAI,CAAC,WAAW,EACpB;YACI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC;SAC/B;KACJ;;;AC5EL;;;;;;;;;;;;;;;;MAgBa,eAAe;;;;IA0BxB,YAAY,QAAuB;;;;;QAM/B,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;;;;;QAMnB,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC,kBAAkB,CAAC;;;;;QAMjD,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;;;;;QAMlD,IAAI,CAAC,aAAa,GAAG,QAAQ,CAAC,YAAY,CAAC;;;;QAK3C,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,qBAAqB,GAAG,EAAE,CAAC;QAChC,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;;;;;QAM3B,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;;;;;;QAOvB,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;;;;;;QAOrB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QAErB,IAAI,IAAI,CAAC,aAAa,KAAK,CAAC,EAC5B;YACI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,iBAAiB,CAAC;SAC7C;aAED;YACI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC;SAC3C;KACJ;;;;;;;;IASD,GAAG,CAAC,YAAgC,EAAE,KAAiB;;QAGnD,IAAI,CAAC,IAAI,CAAC,MAAM,EAChB;YACI,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;SACvB;aACI,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,EACxC;YACI,OAAO,KAAK,CAAC;SAChB;;QAGD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,EAC5B;YACI,OAAO,KAAK,CAAC;SAChB;;QAGD,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAE,YAAoB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,EAC7F;YACI,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAErC,OAAO,IAAI,CAAC;KACf;;;;;;;IAQD,KAAK,CAAC,cAAsB;QAExB,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,EAAc,CAAC;QAE5C,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAExB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;QACvB,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;QACzB,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,oBAAoB,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,qBAAqB,GAAG,EAAE,CAAC;KACnC;;;;;IAMD,KAAK;QAED,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,CAAC;KACzC;;;;IAKD,KAAK;QAED,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;KACxB;;;;;;;IAQD,MAAM;QAEF,OAAO,IAAI,CAAC,UAAU,CAAC;KAC1B;;;;IAKD,IAAI;QAEA,OAAO,IAAI,CAAC,WAAW,CAAC;KAC3B;;;;;;;;;;IAWS,IAAI,CAAC,aAAiC;;QAG5C,OAAO,IAAI,CAAC;KACf;;;;;;;;;;IAWS,SAAS;QAEf,OAAO,IAAI,QAAQ,EAAE,CAAC;KACzB;;;;IAKS,UAAU,CAAC,cAAuB;QAExC,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,CAAC,UAAU,CAAC,MAAM,EAC/C;YACI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC;SAC1C;QAED,MAAM,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;QAElD,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,KAAK,CAAC,cAAc,GAAG,cAAc,CAAC;QAEtC,OAAO,KAAK,CAAC;KAChB;;;;;;;;;;;;;;;;IAiBS,WAAW,CAAC,KAAU;QAE5B,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,qBAAqB,CAAC;QACjD,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC;QACrC,KAAK,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;KAC7B;;IAGO,iBAAiB,CAAC,OAAwC;QAE9D,IAAI,aAAa,IAAI,OAAO,EAC5B;YACI,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;SACjC;QAED,MAAM,WAAW,GAAqB,OAA2B,CAAC;QAElE,IAAI,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,EACxC;YACI,OAAO,IAAI,CAAC;SACf;aACI,IAAI,IAAI,CAAC,oBAAoB,GAAG,CAAC,IAAI,IAAI,CAAC,aAAa,EAC5D;YACI,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;YAC/C,IAAI,CAAC,oBAAoB,IAAI,CAAC,CAAC;YAE/B,MAAM,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC/D,MAAM,KAAK,GAAG,SAAS,GAAG,CAAC,CAAC;YAE5B,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YAE/C,OAAO,IAAI,CAAC;SACf;QAED,OAAO,KAAK,CAAC;KAChB;IAEO,eAAe,CAAC,YAAiC;QAErD,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAE1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAC5C;YACI,MAAM,OAAO,IAAsB,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW;kBACxD,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW;kBAC3B,YAAY,CAAC,CAAC,CAAC,CAAqB,CAAC;YAE3C,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,EACrC;gBACI,EAAE,iBAAiB,CAAC;aACvB;SACJ;QAED,IAAI,iBAAiB,GAAG,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,aAAa,EACtE;YACI,OAAO,KAAK,CAAC;SAChB;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAC5C;YACI,MAAM,OAAO,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW;kBACrC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAW;kBAC3B,YAAY,CAAC,CAAC,CAAC,CAAC;YAEtB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,EACrC;gBACI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC;gBAC3C,IAAI,CAAC,oBAAoB,IAAI,CAAC,CAAC;gBAE/B,MAAM,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;gBAC3D,MAAM,KAAK,GAAG,SAAS,GAAG,CAAC,CAAC;gBAE5B,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;aAC9C;SACJ;QAED,OAAO,IAAI,CAAC;KACf;;;AChVL;AACA;AACA;AACA;MACa,aAAc,SAAQC,QAAa;IAQ5C,YAAY,kBAAuC,EAC/C,QAAiB,EACjB,WAAmB,EACnB,iBAAyB,EACzB,eAAuB,EACvB,eAAuB;QAGvB,KAAK,EAAE,CAAC;QAER,MAAM,eAAe,GAAG,IAAIC,MAAW,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;QAC5D,MAAM,WAAW,GAAG,QAAQ,GAAG,IAAIA,MAAW,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;QAEzE,kBAAkB,CAAC,OAAO,CAAC,CAAC,QAAQ;YAEhC,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,QAAQ,CAAC;YAE9D,IAAI,CAAC,YAAY,CAAC,aAAa,EAAE,eAAe,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;SAChF,CAAC,CAAC;QAEH,IAAI,WAAW,IAAI,iBAAiB,GAAG,CAAC,EACxC;YACI,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,eAAe,EAAE,iBAAiB,EAAE,IAAI,EAAEC,KAAU,CAAC,KAAK,CAAC,CAAC;SAC9F;QACD,IAAI,eAAe,EACnB;YACI,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,eAAe,EAAE,CAAC,EAAE,KAAK,EAAEA,KAAU,CAAC,KAAK,CAAC,CAAC;SACnF;QACD,IAAI,eAAe,EACnB;YACI,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,eAAe,EAAE,CAAC,EAAE,KAAK,EAAEA,KAAU,CAAC,KAAK,CAAC,CAAC;SACnF;QAED,IAAI,QAAQ,EACZ;YACI,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;SAC9B;QAED,IAAI,CAAC,YAAY,GAAG,eAAe,CAAC;QACpC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;KAClC;CACJ;AAED;AACA;MACsB,qBAAqB;;IAGvC,YAAY,QAAuB;;KAGlC;CAMJ;AAED;;;;;;;;;AAUA;;;;;;;;;AAUA;;;;;;;;;;;;;AAcA;;;;;;;AAQA;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;MAyBa,oBAAqB,SAAQ,qBAAqB;;;;IAsC3D,YAAY,QAAuB;QAE/B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAEhB,IAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC;QAC5C,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC;QACxC,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;QACjB,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;QAEjB,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;QAClD,IAAI,CAAC,cAAc,GAAG,QAAQ,CAAC,cAAc,CAAC;QAC9C,IAAI,CAAC,oBAAoB,GAAG,QAAQ,CAAC,oBAAoB,CAAC;QAC1D,IAAI,CAAC,WAAW,GAAG,iBAAiB,CAAC,aAAa,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC1E,IAAI,CAAC,kBAAkB,GAAG,QAAQ,CAAC,kBAAkB,CAAC;QACtD,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;QAClD,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;QAE1C,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;QAClD,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC,gBAAgB,CAAC;QAElD,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,kBAAkB,GAAG,CAAC,CAAC;QAEhD,IAAI,IAAI,CAAC,gBAAgB,EACzB;YACI,IAAI,CAAC,WAAW,IAAI,CAAC,CAAC;SACzB;QACD,IAAI,IAAI,CAAC,gBAAgB,EACzB;YACI,IAAI,CAAC,WAAW,IAAI,CAAC,CAAC;SACzB;QAED,IAAI,IAAI,CAAC,kBAAkB,KAAK,CAAC,EACjC;YACI,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SACnB;aACI,IAAI,IAAI,CAAC,kBAAkB,GAAG,CAAC,EACpC;YACI,IAAI,CAAC,MAAM,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;SACpD;QAED,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;QACpB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;;;;;;;;QASpB,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;KAC3B;;;;;;;;;IAUD,IAAI,CAAC,eAAuB,EAAE,eAAwB;QAElD,IAAI,CAAC,+BAA+B,GAAG,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;QAEhF,IAAI,IAAI,CAAC,cAAc,EACvB;YACI,IAAI,CAAC,2BAA2B,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;SAC3E;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,GAAG,CAAC,CAAC;KACnC;;;;;;;;;IAUD,MAAM,CAAC,YAAgC,EAAE,MAAW;QAEhD,MAAM,KAAK,GAAa,MAAkB,CAAC;QAC3C,MAAM,GAAG,GAAI,YAAoB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;;QAGzD,IAAI,IAAI,CAAC,kBAAkB,KAAK,CAAC,EACjC;YACI,MAAM,MAAM,GAAG,GAAG,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC;YAE/D,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;SACtC;aACI,IAAI,IAAI,CAAC,kBAAkB,GAAG,CAAC,EACpC;YACI,IAAI,IAAI,CAAC;YAET,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EACnC;gBACI,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBAEd,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;gBAEjE,IAAI,CAAC,MAAmB,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;aACvD;SACJ;;QAGD,IAAI,IAAI,CAAC,gBAAgB,EACzB;YACI,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;SAC7D;QACD,IAAI,IAAI,CAAC,gBAAgB,EACzB;YACI,IAAI,CAAC,UAAU,GAAI,KAAgC,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACnF;QAED,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;KAC3C;;;;;;;;;;;;;;;;;IAkBD,KAAK;QAED,MAAM,IAAI,IAAmB,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,IAAI,IAAI,aAAa,CACtE,IAAI,CAAC,gBAAgB,EACrB,IAAI,EACJ,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,kBAAkB,EACvB,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,gBAAgB,CACxB,CAAkB,CAAC;;;QAIpB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,+BAA+B,CAAC,WAAW,CAAC,CAAC;QAC3E,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAC;QAE1D,OAAO,IAAI,CAAC;KACf;;;;;;IAOD,OAAO,CAAC,IAAmB;QAEvB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACjC;;;;;;;;;;;IAYD,IAAc,cAAc;QAExB,IAAI,CAAC,IAAI,CAAC,eAAe,EACzB;;YAEI,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAqB,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,CAAC;SACpE;QAED,OAAO,IAAI,CAAC,eAAe,CAAC;KAC/B;;IAED,IAAc,cAAc,CAAC,IAAgF;QAEzG,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;KAC/B;;;;;;;IAQS,kBAAkB,CAAC,IAAY;;QAGrC,MAAM,SAAS,GAAGC,KAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;QAC3D,MAAM,gBAAgB,GAAGA,KAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACpD,MAAM,WAAW,GAAG,SAAS,GAAG,CAAC,CAAC;QAElC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,gBAAgB,EAC7C;YACI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,gBAAgB,GAAG,CAAC,CAAC;SAChD;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;QAE9C,IAAI,CAAC,MAAM,EACX;YACI,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,MAAM,GAAG,IAAIJ,cAAmB,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC;SAClG;QAED,OAAO,MAAM,CAAC;KACjB;;;;;;;IAQS,cAAc,CAAC,IAAY;;QAGjC,MAAM,SAAS,GAAGI,KAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC;QAC5D,MAAM,gBAAgB,GAAGA,KAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACpD,MAAM,WAAW,GAAG,SAAS,GAAG,EAAE,CAAC;QAEnC,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,gBAAgB,EAC7C;YACI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,gBAAgB,GAAG,CAAC,CAAC;SAChD;QAED,IAAI,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;QAE9C,IAAI,CAAC,MAAM,EACX;YACI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,MAAM,GAAG,IAAI,WAAW,CAAC,WAAW,CAAC,CAAC;SAC5E;QAED,OAAO,MAAM,CAAC;KACjB;CACJ;AAED;AACA,MAAM,iBAAiB,GAAG;IACtB,cAAc,EAAE,mBAAmB;IACnC,kBAAkB,EAAE,iBAAiB;;IAGrC,eAAe,EAAE;QACb,cAAc;QACd,SAAS;KACZ;CACJ,CAAC;AAEF;AACA;AACA;AAEA;AACA;AACA,MAAM,qBAAqB,GAAG;;IAK1B,YAAY,MAA4B;QAEpC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;KACxB;IAED,OAAO;QAEH,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;;QAG3B,IAAI,UAAU,GAAG,EAAE,CAAC;;;QAIpB,MAAM,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;YAExC,UAAU,IAAI;+BACK,CAAC;iCACC,CAAC;sBACZ,IAAI,CAAC,8BAA8B,CAAC,QAAQ,EAAE,CAAC,CAAC;aACzD,CAAC;SACL,CAAC,CAAC;;;QAIH,UAAU,IAAI;;;;;;;;;;;;;;;;;;kCAkBY,IAAI,CAAC,6BAA6B,EAAE;;;;;;SAM7D,CAAC;;;QAIF,IAAI,uBAAuB,GAAG,KAAK,CAAC;;QAGpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EACvD;YACI,MAAM,QAAQ,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;;YAG5C,IAAI,CAAC,uBAAuB,EAC5B;gBACI,UAAU,IAAI;oCACM,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;iBAClC,CAAC;aACL;YAED,IAAI,OAAO,QAAQ,CAAC,IAAI,KAAK,QAAQ,EACrC;gBACI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,EACtC;oBACI,UAAU,IAAI;UACxB,QAAQ,CAAC,IAAI,qCAAqC,CAAC,aAAa,CAAC;qBACtD,CAAC;iBACL;aACJ;iBAED;gBACI,UAAU,IAAI;UACpB,QAAQ,CAAC,IAAI,qCAAqC,CAAC;iBAC5C,CAAC;aACL;YAED,IAAI,MAAM,CAAC,gBAAgB,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAC/E;gBACI,UAAU,IAAI;oCACM,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;iBAClC,CAAC;aACL;iBAED;gBACI,uBAAuB,GAAG,IAAI,CAAC;aAClC;SACJ;QAED,IAAI,uBAAuB,EAC3B;YACI,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,EAC1D;gBACI,UAAU,IAAI;oCACM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;iBACnE,CAAC;gBACF,uBAAuB,GAAG,KAAK,CAAC;aACnC;SACJ;QAED,IAAI,MAAM,CAAC,kBAAkB,GAAG,CAAC,EACjC;YACI,IAAI,MAAM,CAAC,kBAAkB,GAAG,CAAC,EACjC;gBACI,IAAI,CAAC,uBAAuB,EAC5B;oBACI,UAAU,IAAI;;qBAEb,CAAC;iBACL;gBAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,kBAAkB,EAAE,CAAC,EAAE,EAClD;oBACI,UAAU,IAAI;oDACkB,CAAC;qBAChC,CAAC;iBACL;gBAED,UAAU,IAAI;;iBAEb,CAAC;aACL;iBACI,IAAI,CAAC,uBAAuB,EACjC;gBACI,UAAU,IAAI;;iBAEb,CAAC;aACL;iBAED;gBACI,UAAU,IAAI;;;iBAGb,CAAC;aACL;SACJ;QACD,IAAI,MAAM,CAAC,gBAAgB,EAC3B;YACI,UAAU,IAAI;;;aAGb,CAAC;SACL;QACD,IAAI,MAAM,CAAC,gBAAgB,EAC3B;YACI,UAAU,IAAI;;;aAGb,CAAC;SACL;;QAGD,UAAU,IAAI;cACR,IAAI,CAAC,MAAM,CAAC,cAAc;cAC9B,iCAAiC;cACjC,EAAE;;SAEH,CAAC;QAEF,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,EAC9B;YACI,UAAU,IAAI;yCACe,IAAI,CAAC,MAAM,CAAC,WAAW;wCACxB,IAAI,CAAC,MAAM,CAAC,cAAc;;;;sEAII,IAAI,CAAC,MAAM,CAAC,cAAc;;;;aAInF,CAAC;SACL;;QAGD,OAAO,IAAI,QAAQ,CACf,GAAG,iBAAiB,CAAC,eAAe,EACpC,UAAU,CAC4D,CAAC;KAC9E;;;IAID,8BAA8B,CAAC,QAAkB,EAAE,CAAS;QAExD,OAAO,CAAC,OAAO,QAAQ,CAAC,MAAM,KAAK,QAAQ;cACrC,iBAAiB,QAAQ,CAAC,MAAM,IAAI;cACpC,sBAAsB,CAAC,wBAAwB,CAAC;KACzD;IAED,6BAA6B;QAEzB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,EACrC;;YAEI,OAAO,uBACH,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;SAC9C;QAED,QACI,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC,oBAAoB,KAAK,QAAQ;cAC/C,gBAAgB,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE;cAClD,GAAG,IAAI,CAAC,MAAM,CAAC,oBAAoB,EAAE,EAC7C;KACL;IAED,OAAO,CAAC,CAAS;QAEb,OAAOJ,cAAmB,CAAC,MAAM,CAC7B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;KAC7C;CACJ;;SCvqBe,yBAAyB,CAAC,YAAgC,EAAE,QAAyB;IAEjG,OAAO,CAAC,OAAO,QAAQ,KAAK,QAAQ;UAC9B,YAAY,CAAC,QAAQ,CAAC;UACtB,QAAQ,CAAC;AACnB;;SCLgB,yBAAyB,CAAC,YAAgC,EAAE,QAA2B;IAEnG,OAAO,CAAC,OAAO,QAAQ,KAAK,QAAQ;UAC9B,YAAY,CAAC,QAAQ,CAAC;UACtB,QAAQ,CAAC,YAAY,CAAC,CAAC;AACjC;;ACLA;;;;;;;MAOa,WAAW;IAIpB,YAAY,QAAuB;;;;QAK/B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC5B;;;;;;;;IASD,IAAI;QAEA,MAAM,EACF,QAAQ,EACR,aAAa,EAAE,YAAY,EAC3B,gBAAgB,EAAE,eAAe,EACjC,cAAc,EAAE,aAAa,GAChC,GAAI,IAAI,CAAC,QAAQ,CAAC;QAEnB,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC;QACxC,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QACvC,MAAM,IAAI,GAAG,eAAe,CAAC,KAAK,EAAE,CAAC;QACrC,MAAM,EAAE,EAAE,EAAE,GAAG,QAAQ,CAAC;QAExB,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC9B,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACnD,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAE7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EACnC;YACI,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAE3B,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YACvB,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;YAEnD,IAAI,aAAa,EACjB;;gBAEI,EAAE,CAAC,YAAY,CAAC,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC,cAAc,EAAE,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;aACjG;iBAED;;gBAEI,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,CAAC,YAAY,CAAC,CAAC;aACzE;YAED,KAAK,CAAC,KAAK,EAAE,CAAC;SACjB;QAED,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KACjC;;;ACrCL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2Ea,aAAc,SAAQK,cAAmB;;;;;;;;;;;;;;;;;;;;;;;;IAmElD,YAAY,QAAuB,EAAE,OAA8B;QAE/D,KAAK,CAAC,QAAQ,CAAC,CAAC;;;;;;;QAQhB,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,SAAS,CAAC;;;;;;;QAQ1C,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,aAAa,CAAC;;;;;;;QAQ5C,IAAI,CAAC,oBAAoB,GAAG,OAAO,CAAC,mBAAmB,CAAC;;;;;;;QAQxD,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,eAAe,CAAC;;;;;;;;QAShD,IAAI,CAAC,kBAAkB,GAAG,OAAO,OAAO,CAAC,iBAAiB,KAAK,WAAW,GAAG,OAAO,CAAC,iBAAiB,GAAG,CAAC,CAAC;;;;;;;QAQ3G,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,WAAW,CAAC;;;;;;;QAQxC,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,eAAe,CAAC;;;;;;;;QAShD,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,aAAa,KAAK,MAAkBC,KAAU,CAAC,KAAK,EAAE,CAAC,CAAC;;;;;;;;QAStF,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,cAAc,CAAC;;;;;;;;QAS9C,IAAI,CAAC,kBAAkB,GAAG,OAAO,CAAC,iBAAiB,IAAI,eAAe,CAAC;;;;;;;;QASvE,IAAI,CAAC,0BAA0B,GAAG,OAAO,CAAC,yBAAyB,IAAI,oBAAoB,CAAC;;;;;;;;QAS5F,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,gBAAgB,IAAI,WAAW,CAAC;;;;;;;;;QAUjE,IAAI,CAAC,iBAAiB,GAAG,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC;;;;;;;;QASpD,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,eAAe,CAAC;;;;;;;QAQhD,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;;;QAIvB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;;QAI9C,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,EACpB;YACI,IAAI,CAAC,aAAa,EAAE,CAAC;SACxB;QAED,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;KACvB;;;;IAKD,aAAa;QAET,MAAM,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;QAE5B,IAAIC,QAAa,CAAC,UAAU,KAAKC,GAAQ,CAAC,YAAY,EACtD;YACI,IAAI,CAAC,YAAY,GAAG,CAAC,CAAC;SACzB;aAED;YACI,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,YAAY,CAAC,EAAE,CAAC,uBAAuB,CAAC,EAAED,QAAa,CAAC,mBAAmB,CAAC,CAAC;SAChH;;;;;;QAOD,IAAI,CAAC,aAAa,GAAG,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;;;;;;QAOvD,IAAI,CAAC,gBAAgB,GAAG,IAAI,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;;;;;;QAOlE,IAAI,CAAC,OAAO,GAAG,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;KACnD;;;;;;;IAQD,KAAK;QAED,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;QAC9B,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAE1B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;KAC7C;;;;;;;;;;;;;IAcD,MAAM,CAAC,aAAiC;QAEpC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAEvC,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;QAE9D,IAAI,IAAI,CAAC,cAAc,EACvB;YACI,IAAI,CAAC,gBAAgB,IAAI,yBAAyB,CAAC,aAAa,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC;SACjG;KACJ;;;;;;;;;;;;IAaD,KAAK;QAED,MAAM,EAAE,aAAa,EAAE,YAAY,EAAE,gBAAgB,EAAE,eAAe,EAAE,cAAc,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC;QAC/G,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QAClC,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC;;QAGnC,YAAY,CAAC,KAAK,EAAE,CAAC;QACrB,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAEpE,IAAI,UAAU,GAAG,CAAC,CAAC;;QAGnB,KAAK,IAAI,WAAW,GAAG,CAAC,EAAE,WAAW,GAAG,YAAY,GACpD;YACI,MAAM,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;YACnC,MAAM,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,MAAM,EAAE,yBAAyB,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC,CAAC;YAE1F,IAAI,CAAC,MAAM,EACX;gBACI,YAAY,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;gBAC/B,UAAU,GAAG,WAAW,CAAC;aAC5B;iBAED;gBACI,EAAE,WAAW,CAAC;aACjB;SACJ;;QAGD,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,EACzB;YACI,YAAY,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;SAClC;QAED,MAAM,SAAS,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC;QACxC,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QACvC,IAAI,OAAO,GAAG,CAAC,CAAC;;QAGhB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE;SACnC;YACI,MAAM,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YAC3B,MAAM,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;YACtC,MAAM,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;YAEvC,IAAI,WAAW,GAAG,CAAC,CAAC;YACpB,IAAI,UAAU,GAAG,CAAC,CAAC;YAEnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE;aACpC;gBACI,MAAM,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAEpC,IAAI,IAAI,CAAC,cAAc,EACvB;oBACI,UAAU,IAAI,yBAAyB,CAAC,YAAY,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC,MAAM,CAAC;iBACrF;qBAED;oBACI,WAAW,IAAI,yBAAyB,CAAC,YAAY,EAAE,IAAI,CAAC,oBAAoB,CAAC,CAAC;iBACrF;;gBAGD,KAAK,CAAC,YAAY,GAAG,WAAW,CAAC;gBACjC,KAAK,CAAC,WAAW,GAAG,UAAU,CAAC;gBAC/B,KAAK,CAAC,cAAc,GAAG,OAAO,CAAC;gBAC/B,OAAO,IAAI,KAAK,CAAC,WAAW,CAAC;gBAE7B,eAAe,CAAC,MAAM,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;aAC/C;SACJ;;QAGD,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;KACvB;;;;;;IAOD,IAAI;QAEA,IAAI,IAAI,CAAC,iBAAiB,EAC1B;YACI,IAAI,CAAC,KAAK,EAAE,CAAC;SAChB;KACJ;;IAGS,eAAe,CAAC,YAAgC;QAEtD,OAAO,CAAC,IAAI,CAAC,oBAAoB;cAC3B,yBAAyB,CAAC,YAAY,EAAE,IAAI,CAAC,oBAAoB,CAAC;cAClE,yBAAyB,CAAC,YAAY,EACpC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM;kBAChC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAe,CAAC;KAC3D;;;AC7dL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA8Fa,0BAA0B;;;;;;;;;;;;;;;;;;;;;IAsBnC,OAAO,IAAI,CAAC,OAAiC;;QAGzC,OAAO,eAAe,OAAO,CAAC,kBAAkB,IAAI,aAAa;YAE7D,YAAY,QAAuB;gBAE/B,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;aAC5B;SACJ,CAAC;KACL;;;ACzJL;AAEA;AACA;AACA,SAAS,WAAW,CAAC,MAAc,EAAE,MAAc,EAAE,WAAmB;IAEpE,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,WAAW,CAAC,CAAC;AAChE,CAAC;AAED,SAAS,sBAAsB,CAAC,aAA4B;IAExD,OAAO,GAAG,aAAa,CAAC,YAAY,EAAE,CAAC;AAC3C,CAAC;AAED,MAAM,SAAS,GAAG;IACd,gBAAgB,CAAC,QAAuB;QAEpC,OAAO,GAAI,QAAQ,CAAC,aAA+C,CAAC,YAAY,EAAE,CAAC;KACtF;CACJ,CAAC;AAEF;;;;;;;;;;;;;;;;;;MAkBa,kBAAkB;;;;;;;;;;;;IAuB3B,YACI,oBAA4B,EAC5B,sBAA8B,EAC9B,QAAQ,GAAG,EAAE,EACb,oBAAyB,EAAE,EAC3B,2BAA2B,GAAG,IAAI;QAGlC,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,EAC5C;YACI,iBAAiB,CAAC,oBAAoB,CAAC,GAAG,sBAAsB,CAAC;SACpE;QACD,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,EAC5C;YACI,iBAAiB,CAAC,oBAAoB,CAAC,GAAG,SAAS,CAAC,gBAAgB,CAAC;SACxE;QAED,IAAI,CAAC,qBAAqB,GAAG,oBAAoB,CAAC;QAClD,IAAI,CAAC,uBAAuB,GAAG,sBAAsB,CAAC;QACtD,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;;;;;;;QAQ5C,IAAI,CAAC,2BAA2B,GAAG,2BAA2B,CAAC;;;;;;;;QAS/D,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;;;;;;;;QASjB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;KACvB;;;;;;;IAQD,MAAM;QAEF,OAAO,CAAC,aAA4B;YAEhC,MAAM,WAAW,GAAG,IAAI,CAAC,2BAA2B,CAAC,aAAa,CAAC,CAAC;YACpE,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YAE9C,IAAI,YAAY,EAChB;gBACI,OAAO,YAAY,CAAC;aACvB;YAED,OAAO,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;SAC3D,CAAC;KACL;IAES,2BAA2B,CAAC,aAA4B;QAE9D,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QAEjC,KAAK,MAAM,aAAa,IAAI,IAAI,CAAC,kBAAkB,EACnD;YACI,MAAM,GAAG,GAAG,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC,aAAa,CAAC,CAAC;YAElE,KAAK,IAAI,GAAG,CAAC;YACb,MAAM,CAAC,aAAa,CAAC,GAAG,GAAG,CAAC;SAC/B;QAED,OAAO,KAAK,CAAC;KAChB;IAES,eAAe,CAAC,WAAmB,EAAE,QAAuB;QAElE,IAAI,oBAAoB,GAAG,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAE/D,IAAI,sBAAsB,GAAG,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAEnE,KAAK,MAAM,gBAAgB,IAAI,IAAI,CAAC,OAAO,EAC3C;YACI,IAAI,CAAC,IAAI,CAAC,2BAA2B,EACrC;gBACI,oBAAoB,GAAG,WAAW,CAAC,oBAAoB,EACnD,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC;aACzD;YAED,sBAAsB,GAAG,WAAW,CAAC,sBAAsB,EACvD,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC;SACzD;QAED,MAAM,MAAM,GAAGE,MAAW,CAAC,IAAI,CAAC,oBAAoB,EAChD,sBAAsB,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QAE5C,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAElD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EACxC;YACI,QAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SACnB;QACD,MAAM,CAAC,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC;QAErC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QAElC,OAAO,MAAM,CAAC;KACjB;;;ACrLL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA6Ba,sBAAuB,SAAQ,QAAQ;IAQhD,YAAY,QAAuB,EAAE,cAAuB;QAExD,KAAK,CAAC,cAAc,CAAC,CAAC;;;;;QAMtB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;;;;;QAMzB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;;;;;QAM1B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;;;;;QAMvB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;KAC1B;;;;;IAMD,MAAM,CAAC,QAAuB;QAE1B,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAEvB,MAAM,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE/E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EACvD;YACI,MAAM,aAAa,GAAG,gBAAgB,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;YAExD,MAAM,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;SACtE;;KAGJ;;;;IAKD,KAAK;QAED,KAAK,CAAC,KAAK,EAAE,CAAC;QAEd,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,aAAa,EAC5C;YACI,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;SAC9C;KACJ;;;AChGL;;;;;;;;MAQa,6BAA8B,SAAQ,eAAe;IAQ9D,YAAY,QAAuB;QAE/B,KAAK,CAAC,QAAQ,CAAC,CAAC;;;;;;;;QAShB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,KAAK,CAC1B,IAAI,CAAC,GAAG,CACJ,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,0BAA0B,CAAC,EAClF,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,4BAA4B,CAAC,CAAC;eACtF,CAAC,GAAG,QAAQ,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC;QAE/C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACrB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;KAC1B;;;;IAKD,SAAS;QAEL,MAAM,KAAK,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;;QAGzD,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAClD,KAAK,CAAC,UAAU,GAAG,EAAE,CAAC;QAEtB,OAAO,KAAK,CAAC;KAChB;;;;;;;;;;;;;;;;;;;;;;IAuBS,IAAI,CAAC,aAAiC;QAE5C,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,gBAAgB,EACpC;;YAEI,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,EAC1B;gBACI,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;gBAE9C,IAAI,EAAE,GAAG,CAAC,EACV;oBACI,OAAO,IAAI,CAAC;iBACf;gBAED,OAAO,KAAK,CAAC;aAChB;SACJ;QAED,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,IAAI,IAAI,CAAC,YAAY,EAC/C;YACI,OAAO,KAAK,CAAC;SAChB;QAED,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,EACnC;YACI,MAAM,EAAE,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC;YAE9C,IAAI,EAAE,GAAG,CAAC,EACV;gBACI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBAEzB,OAAO,IAAI,CAAC;aACf;SACJ;;QAGD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EACvE;YACI,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAC5D,MAAM,EAAE,MAAM,EAAE,aAAa,EAAE,GAAG,eAAe,CAAC;YAElD,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,OAAO,MAAM,KAAK,QAAQ;kBAC1D,aAAqB,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC;SACjE;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACzC,EAAE,IAAI,CAAC,aAAa,CAAC;QAErB,OAAO,IAAI,CAAC;KACf;;;;;IAMD,WAAW,CAAC,KAAU;QAElB,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAEzB,MAAM,MAAM,GAAG,KAAK,CAAC,aAAa,CAAC;QACnC,MAAM,GAAG,GAAG,KAAK,CAAC,UAAU,CAAC;QAE7B,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACzC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QACnC,KAAK,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;;QAGzC,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC;QAC5B,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC7C,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;KAC9B;;;;;;IAOO,oBAAoB;QAExB,MAAM,MAAM,GAA+C,EAAE,CAAC;QAE9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EACvE;YACI,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAE5D,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC;SAC9C;QAED,OAAO,MAAM,CAAC;KACjB;;;;;IAMO,mBAAmB,CAAC,MAAkD;QAE1E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EACvE;YACI,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAE5D,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC;SACpD;KACJ;;;;IAKO,cAAc,CAAC,aAAkB;QAErC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC;QAElD,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAChD;YACI,IAAI,OAAO,GAAG,IAAI,CAAC;YAEnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAC/C;gBACI,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAE9C,MAAM,KAAK,GAAG,OAAO,MAAM,KAAK,QAAQ;sBAClC,aAAa,CAAC,MAAM,CAAC;sBACrB,MAAM,CAAC,aAAmC,CAAC,CAAC;gBAElD,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,EACvE;oBACI,OAAO,GAAG,KAAK,CAAC;oBAChB,MAAM;iBACT;aACJ;YAED,IAAI,OAAO,EACX;gBACI,OAAO,CAAC,CAAC;aACZ;SACJ;QAED,OAAO,CAAC,CAAC,CAAC;KACb;;IAGO,gBAAgB,CAAC,EAAO,EAAE,EAAO;QAErC,IAAI,EAAE,KAAK,EAAE,EACb;YACI,OAAO,IAAI,CAAC;SACf;;QAGD,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,KAAK,EACxB;YACI,OAAO,KAAK,CAAC;SAChB;;QAGD,IAAI,EAAE,CAAC,MAAM,EACb;YACI,OAAO,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACxB;;QAGD,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,EAC1C;YACI,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM,EAC3B;gBACI,OAAO,KAAK,CAAC;aAChB;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EACzC;;gBAEI,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,EACnB;oBACI,OAAO,KAAK,CAAC;iBAChB;aACJ;YAED,OAAO,IAAI,CAAC;SACf;QAED,IAAI,EAAE,YAAYC,KAAU,IAAI,EAAE,YAAYA,KAAU,EACxD;YACI,OAAO,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SACzC;QACD,IAAI,EAAE,YAAYC,MAAW,IAAI,EAAE,YAAYA,MAAW,EAC1D;YACI,OAAO,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;mBAC9B,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;mBAC9B,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;SAC7C;;QAGD,IAAI,EAAE,YAAYC,WAAgB,IAAI,EAAE,YAAYA,WAAgB,EACpE;YACI,OAAO,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,CAAC;SAC5B;QAED,OAAO,IAAI,CAAC;KACf;;;AC1QL;;;;;;;;;;;;AAaA;;;;;;;;;;AAWA;;;;;;;;;;;"}