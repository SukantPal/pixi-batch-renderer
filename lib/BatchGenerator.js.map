{"version":3,"sources":["../src/BatchGenerator.js"],"names":["BatchGenerator","textureIncrement","textureLimit","textureProperty","enableTextureReduction","_state","_textureIncrement","_textureLimit","_textureProperty","_batchBuffer","_textureBuffer","_textureBufferLength","_textureIndexedBuffer","_textureIndexMap","_putTexture","_putOnlyTexture","_putTextureArray","_putTextureWithoutReduction","_putTextureArrayWithoutReduction","targetObject","state","data","onPut","push","batch","batchBuffer","textureBuffer","uidMap","texture","baseTexture","uid","newLength","index","textureArray","deltaBufferLength","i","length"],"mappings":"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","sourcesContent":["/**\n * Used to generate discrete groups/batches of display-objects\n * that can be drawn together. It also keeps a parallel buffer\n * of textures.\n *\n * This class ensures that the WebGL states are equivalent and\n * the texture count doesn't become greater than the no. of\n * texture registers on the GPU. You can extend it and add\n * constraints by overriding `onPut`.\n *\n * // WARNING: `BatchRenderer` does not support geometry\n *              packing with texture reduction disabled.\n */\nexport class BatchGenerator\n{\n    /**\n     * @param {number} textureIncrement - textures per object\n     * @param {number} textureLimit - no. of texture registers in GPU\n     * @param {string} textureProperty - property where texture is kept\n     * @param {boolean} [enableTextureReduction=true] - whether same textures\n     *      aren't counted multiple times. This reduces draw calls and can\n     *      draw huge amounts of objects at the same time. For example,\n     *      if 1000 objects use the same texture, then they can be drawn\n     *      together. Further more if 1000 object use the same 8 textures\n     *      randomly, then they can be drawn together. (provided other\n     *      constraints like state are satisfied.)\n     */\n    constructor(\n        textureIncrement,\n        textureLimit,\n        textureProperty,\n        enableTextureReduction = true\n    )\n    {\n        /** @private */\n        this._state = null;\n        /** @private */\n        this._textureIncrement = textureIncrement;\n        /** @private */\n        this._textureLimit = textureLimit;\n        /** @private */\n        this._textureProperty = textureProperty;\n        /** @private */\n        this._batchBuffer = [];\n        /** @private */\n        this._textureBuffer = {}; // uid : texture map\n        /** @private */\n        this._textureBufferLength = 0;\n        /** @private */\n        this._textureIndexedBuffer = []; // array of textures\n        /** @private */\n        this._textureIndexMap = {}; // uid : index in above\n        /** @protected */\n        this.enableTextureReduction = enableTextureReduction;\n\n        // this._putTexture is used to handle texture buffering!\n        if (enableTextureReduction)\n        {\n            if (textureIncrement === 1)\n            {\n                /** @private */\n                this._putTexture = this._putOnlyTexture;\n            }\n            else\n            {\n                this._putTexture = this._putTextureArray;\n            }\n        }\n        else if (textureIncrement === 1)\n        {\n            this._putTexture = this._putTextureWithoutReduction;\n        }\n        else\n        {\n            this._putTexture = this._putTextureArrayWithoutReduction;\n        }\n    }\n\n    /**\n     * Overridable method that is called before an object\n     * is put into this batch. It should check compatibility\n     * with other objects, and return true/false accordingly.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object being added\n     * @protected\n     */\n    onPut(targetObject)// eslint-disable-line no-unused-vars\n    {\n        return true;\n    }\n\n    /**\n     * Put an object into this batch.\n     *\n     * @param targetObject {PIXI.DisplayObject} - object to add\n     * @param state {PIXI.State} - state required by that object\n     * @return {boolean} whether the object was added to the\n     *     batch.\n     */\n    put(targetObject, state)\n    {\n        if (!this._state)\n        {\n            this._state = state;\n        }\n        else if (this._state.data !== state.data)\n        {\n            return false;\n        }\n\n        if (!this.onPut(targetObject))\n        {\n            return false;\n        }\n\n        if (this._textureIncrement > 0\n            && !this._putTexture(targetObject[this._textureProperty]))\n        {\n            return false;\n        }\n\n        this._batchBuffer.push(targetObject);\n\n        return true;\n    }\n\n    /**\n     * Finalize this batch by getting its data into a\n     * `Batch` object.\n     *\n     * @param batch {PIXI.brend.Batch}\n     */\n    finalize(batch)\n    {\n        batch.batchBuffer = this._batchBuffer;\n        batch.textureBuffer = this._textureIndexedBuffer;\n        batch.uidMap = this.enableTextureReduction\n            ? this._textureIndexMap : null;\n        batch.state = this._state;\n\n        this._state = null;\n        this._batchBuffer = [];\n        this._textureBuffer = {};\n        this._textureIndexMap = {};\n        this._textureBufferLength = 0;\n        this._textureIndexedBuffer = [];\n    }\n\n    _putOnlyTexture(texture)\n    {\n        if (texture.baseTexture)\n        {\n            texture = texture.baseTexture;\n        }\n\n        if (this._textureBuffer[texture.uid])\n        {\n            return true;\n        }\n        else if (this._textureBufferLength + 1 <= this._textureLimit)\n        {\n            this._textureBuffer[texture.uid] = texture;\n            this._textureBufferLength += 1;\n\n            const newLength = this._textureIndexedBuffer.push(texture);\n            const index = newLength - 1;\n\n            this._textureIndexMap[texture.uid] = index;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    _putTextureArray(textureArray)\n    {\n        let deltaBufferLength = 0;\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture = textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i];\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                ++deltaBufferLength;\n            }\n        }\n\n        if (deltaBufferLength + this._textureBufferLength > this._textureLimit)\n        {\n            return false;\n        }\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            const texture = textureArray[i].baseTexture\n                ? textureArray[i].baseTexture\n                : textureArray[i];\n\n            if (!this._textureBuffer[texture.uid])\n            {\n                this._textureBuffer[texture.uid] = texture;\n                this._textureBufferLength += 1;\n\n                const newLength = this._textureIndexedBuffer.push(texture);\n                const index = newLength - 1;\n\n                this._textureIndexMap[texture.uid] = index;\n            }\n        }\n\n        return true;\n    }\n\n    _putTextureWithoutReduction(texture)\n    {\n        if (texture.baseTexture)\n        {\n            texture = texture.baseTexture;\n        }\n\n        if (this._textureBufferLength + 1 > this._textureLimit)\n        {\n            return false;\n        }\n\n        this._textureIndexedBuffer.push(texture);\n\n        return true;\n    }\n\n    _putTextureArrayWithoutReduction(textureArray)\n    {\n        if (this._textureBufferLength + textureArray.length\n            > this._textureLimit)\n        {\n            return false;\n        }\n\n        for (let i = 0; i < textureArray.length; i++)\n        {\n            this._textureIndexedBuffer.push(\n                textureArray[i].baseTexture\n                    ? textureArray[i].baseTexture\n                    : textureArray[i]\n            );\n        }\n\n        return true;\n    }\n}\n\nexport default BatchGenerator;\n"],"file":"BatchGenerator.js"}