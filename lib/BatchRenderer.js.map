{"version":3,"sources":["../src/BatchRenderer.js"],"names":["BatchRenderer","renderer","attributeRedirects","indexProperty","vertexCountProperty","textureProperty","texturePerObject","textureAttribute","stateFunction","shaderFunction","packer","GeometryPacker","undefined","BatchGeneratorClass","BatchGenerator","_attributeRedirects","_indexProperty","_vertexCountProperty","_textureProperty","_texturePerObject","_textureAttribute","_stateFunction","_shaderFunction","_BatchGeneratorClass","_batchGenerator","runners","contextChange","add","gl","_packer","_geom","generateCompositeGeometry","_objectBuffer","_bufferedVertices","_bufferedIndices","_shader","_batchPool","_batchCount","_renderId","PIXI","settings","PREFER_ENV","ENV","WEBGL_LEGACY","MAX_TEXTURES","Math","min","getParameter","MAX_TEXTURE_IMAGE_UNITS","SPRITE_MAX_TEXTURES","enableTextureReduction","Error","length","uniforms","uSamplers","generateTextureArray","shader","bind","targetObject","push","_vertexCountFor","batchGenerator","geom","buffer","bufferLength","reset","batchStart","objectIndex","target","wasPut","put","finalize","_newBatch","_batchBuffer","textureId","Array","i","batch","batchBuffer","batchLength","uidMap","vertexCount","indexCount","j","$vertexCount","$indexCount","tex","texUID","baseTexture","uid","_tex","k","BaseTexture","pack","$buffer","update","compositeAttributes","float32View","getIndex","compositeIndices","geometry","updateBuffers","console","log","textureBuffer","forEach","texture","state","set","drawElements","TRIANGLES","UNSIGNED_SHORT","geometryOffset","drawArrays","flush","Batch","source","size","hasIndex","Geometry","attributeBuffer","Buffer","indexBuffer","redirect","glslIdentifer","glType","glSize","normalize","addAttribute","TYPES","FLOAT","addIndex","count","array","Int32Array","ObjectRenderer"],"mappings":"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","sourcesContent":["import { Batch } from './Batch';\nimport { BatchGenerator } from './BatchGenerator';\nimport { GeometryPacker } from './GeometryPacker';\nimport * as PIXI from 'pixi.js';\nimport { resolveConstantOrProperty, resolveFunctionOrProperty } from './resolve';\n\n/**\n * @memberof PIXI.brend\n */\nexport class BatchRenderer extends PIXI.ObjectRenderer\n{\n    /**\n     * @param {PIXI.Renderer} renderer - renderer to attach to\n     * @param {Array<PIXI.brend.AttributeRedirect>} attributeRedirects\n     * @param {string | null} indexProperty\n     * @param {string | number} vertexCountProperty\n     * @param {string | null} textureProperty\n     * @param {number} texturePerObject\n     * @param {string} textureAttribute - name of texture-id attribute variable\n     * @param {Function} stateFunction - returns a {PIXI.State} for an object\n     * @param {Function} shaderFunction - generates a shader given this instance\n     * @param {PIXI.brend.GeometryPacker} [packer=new PIXI.brend.GeometryPacker]\n     * @param {Class} [BatchGeneratorClass=PIXI.brend.BatchGenerator]\n     *\n     * @see\n     */\n    constructor(// eslint-disable-line max-params\n        renderer,\n        attributeRedirects,\n        indexProperty,\n        vertexCountProperty,\n        textureProperty,\n        texturePerObject,\n        textureAttribute,\n        stateFunction,\n        shaderFunction,\n        packer = new GeometryPacker(\n            attributeRedirects,\n            indexProperty,\n            vertexCountProperty, // auto-calculate\n            undefined,\n            texturePerObject\n        ),\n        BatchGeneratorClass = BatchGenerator\n    )\n    {\n        super(renderer);\n\n        /** @protected */\n        this._attributeRedirects = attributeRedirects;\n        /** @protected */\n        this._indexProperty = indexProperty;\n        /** @protected */\n        this._vertexCountProperty = vertexCountProperty;\n        /** @protected */\n        this._textureProperty = textureProperty;\n        /** @protected */\n        this._texturePerObject = texturePerObject;\n        /** @protected */\n        this._textureAttribute = textureAttribute;\n        /** @protected */\n        this._stateFunction = stateFunction;\n        /** @protected */\n        this._shaderFunction = shaderFunction;\n\n        /** @protected */\n        this._BatchGeneratorClass = BatchGeneratorClass;\n        /** @protected */\n        this._batchGenerator = null;// @see this#contextChange\n\n        this.renderer.runners.contextChange.add(this);\n\n        if (this.renderer.gl)// we are late to the party!\n        {\n            this.contextChange();\n        }\n\n        /** @protected */\n        this._packer = packer;\n\n        /** @protected */\n        this._geom = BatchRenderer.generateCompositeGeometry(\n            attributeRedirects,\n            !!indexProperty,\n            textureAttribute,\n            texturePerObject);\n\n        /** @protected */\n        this._objectBuffer = [];\n        /** @protected */\n        this._bufferedVertices = 0;\n        /** @protected */\n        this._bufferedIndices = 0;\n        /** @private */\n        this._shader = null;\n\n        /** @protected */\n        this._batchPool = [];// may contain garbage after _batchCount\n        /** @protected */\n        this._batchCount = 0;\n\n        this._renderId = 0;\n    }\n\n    /** @override */\n    contextChange()\n    {\n        const gl = this.renderer.gl;\n\n        if (PIXI.settings.PREFER_ENV === PIXI.ENV.WEBGL_LEGACY)\n        {\n            /** @protected */\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            this.MAX_TEXTURES = Math.min(\n                gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),\n                PIXI.settings.SPRITE_MAX_TEXTURES);\n        }\n\n        this._batchGenerator = new this._BatchGeneratorClass(\n            this._texturePerObject, this.MAX_TEXTURES,\n            this._textureProperty, true); // NOTE: Force texture reduction\n\n        if (!this._batchGenerator.enableTextureReduction)\n        {\n            throw new Error('PIXI.brend.BatchRenderer does not support '\n                    + 'batch generation without texture reduction enabled.');\n        }\n    }\n\n    /** @override */\n    start()\n    {\n        this._objectBuffer.length = 0;\n        this._bufferedVertices = 0;\n        this._bufferedIndices = 0;\n\n        this._shader = this._shaderFunction(this);\n\n        if (this._shader.uniforms.uSamplers)\n        {\n            this._shader.uniforms.uSamplers\n                = BatchRenderer.generateTextureArray(this.MAX_TEXTURES);\n        }\n\n        this.renderer.shader.bind(this._shader);\n    }\n\n    /** @override */\n    render(targetObject)\n    {\n        this._objectBuffer.push(targetObject);\n\n        this._bufferedVertices += this._vertexCountFor(targetObject);\n\n        if (this._indexProperty)\n        {\n            this._bufferedIndices += resolveConstantOrProperty(\n                targetObject, this._indexProperty).length;\n        }\n    }\n\n    /** @override */\n    flush()\n    {\n        const {\n            _batchGenerator: batchGenerator,\n            _geom: geom,\n            _packer: packer,\n            renderer,\n            _stateFunction: stateFunction,\n            _textureProperty: textureProperty,\n            _texturePerObject: texturePerObject,\n        } = this;\n\n        const gl = renderer.gl;\n        const buffer = this._objectBuffer;\n        const bufferLength = buffer.length;\n\n        this._batchCount = 0;\n        packer.reset(this._bufferedVertices, this._bufferedIndices);\n\n        let batchStart = 0;\n\n        // Generate batches/groups that will be drawn using just\n        // one draw call.\n        for (let objectIndex = 0; objectIndex < bufferLength;)\n        {\n            const target = buffer[objectIndex];\n            const wasPut = batchGenerator.put(target,\n                resolveFunctionOrProperty(target, stateFunction));\n\n            if (!wasPut)\n            {\n                batchGenerator.finalize(this._newBatch(batchStart));\n                batchStart = objectIndex;\n            }\n            else\n            {\n                ++objectIndex;\n            }\n        }\n\n        // Generate the last batch, if required.\n        if (batchGenerator._batchBuffer.length !== 0)\n        {\n            batchGenerator.finalize(this._newBatch(batchStart));\n        }\n\n        // Pack each object into the composite geometry. This is done\n        // after batching, so that texture-ids are generated.\n        let textureId = this.texturePerObject === 1\n            ? 0\n            : new Array(texturePerObject);\n\n        for (let i = 0; i < this._batchCount; i++)// loop-per(batch)\n        {\n            const batch = this._batchPool[i];\n            const batchBuffer = batch.batchBuffer;\n            const batchLength = batchBuffer.length;\n            const uidMap = batch.uidMap;\n\n            let vertexCount = 0;// eslint-disable-line\n            let indexCount = 0;\n\n            for (let j = 0; j < batchLength; j++)// loop-per(targetObject)\n            {\n                const targetObject = batchBuffer[j];\n\n                if (this._indexProperty)\n                {\n                    indexCount += resolveConstantOrProperty(\n                        targetObject, this._indexProperty).length;\n                }\n                else\n                {\n                    vertexCount += resolveConstantOrProperty(\n                        targetObject, this._vertexCountProperty);\n                }\n\n                // externally-defined properties for draw calls\n                batch.$vertexCount = vertexCount;\n                batch.$indexCount = indexCount;\n\n                const tex = targetObject[textureProperty];\n\n                let texUID;\n\n                if (texturePerObject === 1)\n                {\n                    texUID = tex.baseTexture\n                        ? tex.baseTexture.uid\n                        : tex.uid;\n\n                    textureId = uidMap[texUID];\n                }\n                else\n                {\n                    let _tex;\n\n                    for (let k = 0; k < tex.length; k++)\n                    {\n                        _tex = tex[k];\n\n                        texUID = _tex.BaseTexture\n                            ? _tex.baseTexture.uid\n                            : _tex.uid;\n\n                        textureId[k] = uidMap[texUID];\n                    }\n                }\n\n                packer.pack(targetObject, textureId);\n            }\n        }\n\n        // Upload the geometry\n        geom.$buffer.update(packer.compositeAttributes.float32View);\n        geom.getIndex().update(packer.compositeIndices);\n        renderer.geometry.bind(geom);\n        renderer.geometry.updateBuffers();\n\n        if (this._renderId === 0)\n        { console.log(this._batchPool); console.log(this._packer); }\n\n        // Now draw each batch\n        for (let i = 0; i < this._batchCount; i++)\n        {\n            const batch = this._batchPool[i];\n\n            batch.textureBuffer.forEach((texture, j) =>\n            {\n                renderer.texture.bind(texture, j);\n            });\n\n            renderer.state.set(batch.state);\n\n            if (this._indexProperty)\n            {\n                gl.drawElements(gl.TRIANGLES,\n                    batch.$indexCount,\n                    gl.UNSIGNED_SHORT,\n                    batch.geometryOffset * 2);// * 2 cause Uint16 indices\n            }\n            else\n            {\n                gl.drawArrays(gl.TRIANGLES,\n                    batch.geometryOffset,\n                    batch.$vertexCount);// TODO: *vertexSize\n            }\n        }\n\n        ++this._renderId;\n    }\n\n    stop()\n    {\n        if (this._bufferedVertices)\n        { this.flush(); }\n    }\n\n    /** @private */\n    _newBatch(batchStart)\n    {\n        if (this._batchCount === this._batchPool.length)\n        {\n            const batch = new Batch(batchStart);\n\n            this._batchPool.push(batch);\n            ++this._batchCount;\n\n            return batch;\n        }\n\n        const batch = this._batchPool[this._batchCount++];\n\n        batch.reset();\n        batch.geometryOffset = batchStart;\n\n        return batch;\n    }\n\n    _vertexCountFor(targetObject)\n    {\n        return (this._vertexCountProperty)\n            ? resolveConstantOrProperty(targetObject, this._vertexCountProperty)\n            : resolveFunctionOrProperty(targetObject,\n                this._attributeRedirects[0].source).length\n                    / this._attributeRedirects[0].size;\n    }\n\n    /** @protected */\n    static generateCompositeGeometry(attributeRedirects, hasIndex,\n        textureAttribute, texturePerObject)\n    {\n        const geom = new PIXI.Geometry();\n        const attributeBuffer = new PIXI.Buffer(null, false, false);\n        const indexBuffer = hasIndex ? new PIXI.Buffer(null, false, true) : null;\n\n        attributeRedirects.forEach((redirect) =>\n        {\n            const {\n                glslIdentifer, glType, glSize,\n                normalize,\n            } = redirect;\n\n            geom.addAttribute(glslIdentifer, attributeBuffer,\n                glSize, normalize, glType);\n        });\n\n        if (textureAttribute && texturePerObject > 0)\n        {\n            geom.addAttribute(textureAttribute, attributeBuffer,\n                texturePerObject, true, PIXI.TYPES.FLOAT);\n        }\n\n        if (hasIndex)\n        {\n            geom.addIndex(indexBuffer);\n        }\n\n        geom.$buffer = attributeBuffer;\n\n        // $buffer is attributeBuffer\n        // getIndex() is ?indexBuffer\n        return geom;\n    }\n\n    /** @protected */\n    static generateTextureArray(count)\n    {\n        const array = new Int32Array(count);\n\n        for (let i = 0; i < count; i++)\n        {\n            array[i] = i;\n        }\n\n        return array;\n    }\n}\n\nexport default BatchRenderer;\n"],"file":"BatchRenderer.js"}