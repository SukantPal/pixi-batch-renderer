{"version":3,"sources":["../../src/redirects/AttributeRedirect.js"],"names":["AttributeRedirect","source","glslIdentifer","type","size","glType","PIXI","TYPES","FLOAT","glSize","normalize","properSize","attributeRedirects","reduce","acc","redirect","ViewableBuffer","sizeOf","Redirect"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;IAQMA,iB;;;AAEF,6BAAYC,MAAZ,EAAoBC,aAApB,EAIA;AAAA;;AAAA,QAHIC,IAGJ,uEAHW,SAGX;AAAA,QAHsBC,IAGtB,uEAH6B,CAG7B;AAAA,QAFIC,MAEJ,uEAFaC,IAAI,CAACC,KAAL,CAAWC,KAExB;AAAA,QAF+BC,MAE/B;AAAA,QADIC,SACJ,uEADgB,KAChB;AAAA;AACI,6HAAMT,MAAN,EAAcC,aAAd;AASA,UAAKC,IAAL,GAAYA,IAAZ;AAWA,UAAKC,IAAL,GAAYA,IAAZ;AAOA,UAAKO,UAAL,GAAmBP,IAAI,KAAK,YAAV,GAA0B,CAA1B,GAA8BA,IAAhD;AAcA,UAAKC,MAAL,GAAcA,MAAd;AASA,UAAKI,MAAL,GAAcA,MAAd;AAQA,UAAKC,SAAL,GAAiBA,SAAjB;AA3DJ;AA4DC;;;;kCAEoBE,kB,EACrB;AACI,aAAOA,kBAAkB,CAACC,MAAnB,CACH,UAACC,GAAD,EAAMC,QAAN;AAAA,eACKT,IAAI,CAACU,cAAL,CAAoBC,MAApB,CAA2BF,QAAQ,CAACZ,IAApC,IACKY,QAAQ,CAACJ,UADf,GAEEG,GAHN;AAAA,OADG,EAKH,CALG,CAAP;AAMH;;;EA5E2BI,mB;;;eAiFjBlB,iB","sourcesContent":["import * as PIXI from 'pixi.js';\nimport { Redirect } from './Redirect';\n\n/**\n * An attribute-redirect describes how the batch renderer will\n * aggregate shader attributes.\n *\n * @memberof PIXI.brend\n */\nclass AttributeRedirect extends Redirect\n{\n    constructor(source, glslIdentifer,\n        type = 'float32', size = 0,\n        glType = PIXI.TYPES.FLOAT, glSize,\n        normalize = false)\n    {\n        super(source, glslIdentifer);\n\n        /**\n         * View on the source buffer that should be used to\n         * extract data.\n         *\n         * @member {string}\n         * @see PIXI.ViewableBuffer#view\n         */\n        this.type = type;\n\n        /**\n         * Number of elements to extract out of `source` with\n         * the given view type, for one vertex.\n         *\n         * If source isn't an array (only one element), then\n         * you can set this to `'%notarray%'`.\n         *\n         * @member {number | '%notarray%'}\n         */\n        this.size = size;\n\n        /**\n         * This is equal to `size` or 1 if size is `%notarray%`.\n         *\n         * @member {number}\n         */\n        this.properSize = (size === '%notarray%') ? 1 : size;\n\n        /**\n         * Type of attribute, when uploading.\n         *\n         * Normally, you would use the corresponding type for\n         * the view on source. However, to speed up uploads\n         * you can aggregate attribute values in larger data\n         * types. For example, an RGBA vec4 (byte-sized channels)\n         * can be represented as one `Uint32`, while having\n         * a `glType` of `UNSIGNED_BYTE`.\n         *\n         * @member {PIXI.TYPES}\n         */\n        this.glType = glType;\n\n        /**\n         * Size of attribute in terms of `glType`.\n         *\n         * Note that `glSize * glType <= size * type`\n         *\n         * @readonly\n         */\n        this.glSize = glSize;\n\n        /**\n         * Whether to normalize the attribute values.\n         *\n         * @member {boolean}\n         * @readonly\n         */\n        this.normalize = normalize;\n    }\n\n    static vertexSizeFor(attributeRedirects)\n    {\n        return attributeRedirects.reduce(\n            (acc, redirect) =>\n                (PIXI.ViewableBuffer.sizeOf(redirect.type)\n                    * redirect.properSize)\n                + acc,\n            0);\n    }\n}\n\nexport { AttributeRedirect };\n\nexport default AttributeRedirect;\n"],"file":"AttributeRedirect.js"}